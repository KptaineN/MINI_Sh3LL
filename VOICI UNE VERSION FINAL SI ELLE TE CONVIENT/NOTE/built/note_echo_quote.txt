REMOVE_QUOTES
Cette fonction `remove_quotes()` implémente un **système de suppression de guillemets** qui traite une chaîne de caractères en retirant les guillemets simples et doubles selon les règles de quotage des shells Unix, tout en préservant le contenu protégé par ces guillemets.

La fonction utilise une **architecture à deux index** avec `i` pour parcourir la chaîne source et `j` pour construire la chaîne résultante. Les variables booléennes `in_sq` et `in_dq` suivent l'état de quotage courant, indiquant respectivement si le parsing se trouve à l'intérieur de guillemets simples (single quotes) ou de guillemets doubles (double quotes). Cette approche d'état permet de gérer correctement les règles complexes d'imbrication et d'échappement des guillemets dans les shells.

La **phase d'allocation** utilise `rq_alloc(arg)` pour déterminer et allouer la taille appropriée du buffer de résultat. Cette fonction auxiliaire calcule probablement la taille nécessaire en tenant compte du fait que la suppression des guillemets réduira la longueur de la chaîne finale. La vérification `if (!res)` protège contre les échecs d'allocation mémoire, permettant une gestion gracieuse des erreurs de ressources.

La **boucle de traitement principale** parcourt chaque caractère de la chaîne source et délègue la logique de gestion des guillemets à `rq_handle_quote(arg[i], &in_sq, &in_dq)`. Cette fonction retourne probablement `true` si le caractère courant est un guillemet qui doit être supprimé (et met à jour l'état de quotage), ou `false` si le caractère doit être préservé dans la sortie. Cette séparation des responsabilités maintient une logique claire entre la gestion de l'état et le traitement des caractères.

Le **mécanisme de copie conditionnelle** utilise la valeur de retour de `rq_handle_quote()` pour déterminer l'action à effectuer : si la fonction retourne `true`, seul l'index source `i` est incrémenté (le caractère guillemet est ignoré) ; sinon, le caractère est copié vers la position `j` de la chaîne résultante et les deux index sont avancés. Cette logique garantit que seuls les caractères non-guillemets sont préservés dans le résultat final, tout en maintenant la synchronisation correcte des positions de lecture et d'écriture.

RQ_ALLOC
Cette fonction `rq_alloc()` implémente un **allocateur de mémoire simplifié** pour le système de suppression de guillemets, calculant et allouant dynamiquement un buffer de taille appropriée pour stocker le résultat du traitement de déquotage d'une chaîne de caractères.

La fonction utilise une **stratégie d'allocation conservative** en allouant exactement `ft_strlen(arg) + 1` octets, soit la taille de la chaîne source plus un octet pour le caractère de fin de chaîne `\0`. Cette approche garantit que le buffer sera toujours suffisamment grand pour contenir le résultat, même dans le cas extrême où aucun guillemet ne serait supprimé de la chaîne originale. Le `+ 1` est crucial car il réserve l'espace nécessaire pour le terminateur de chaîne, évitant les dépassements de buffer lors de l'ajout du caractère de fin.

Cette **allocation par la taille maximale** constitue un compromis pragmatique entre simplicité et efficacité mémoire. Bien que cette approche puisse allouer plus d'espace que strictement nécessaire (dans les cas où de nombreux guillemets sont supprimés), elle évite la complexité d'un pré-calcul précis de la taille finale. Cette stratégie est particulièrement adaptée aux chaînes de commande shell qui sont typiquement courtes, rendant le surcoût mémoire négligeable comparé à la simplification du code.

Le **cast explicite** `(char *)` est utilisé pour convertir le pointeur générique `void *` retourné par `malloc()` vers un pointeur de caractères, respectant les bonnes pratiques de programmation C qui recommandent de clarifier explicitement les types de retour. Cette fonction sert de primitive d'allocation spécialisée pour le module de déquotage, encapsulant la logique de calcul de taille et permettant une modification future de la stratégie d'allocation sans affecter le code appelant.

Le nom `rq_alloc` suggère "remove quotes allocation", indiquant clairement son rôle dans le système de suppression de guillemets et facilitant la lisibilité du code dans ce contexte spécialisé de traitement des chaînes quotées.

RQ_HANDLE_QUOTE
Cette fonction `rq_handle_quote()` implémente un **gestionnaire d'état de guillemets** qui gère les règles de quotage des shells Unix, déterminant si un caractère de guillemet doit être supprimé et mettant à jour l'état de parsing en conséquence selon les conventions d'imbrication et de protection mutuelle des guillemets.

La fonction traite d'abord les **guillemets simples** avec `if (c == '\'' && !*in_dq)`, vérifiant que le caractère est un guillemet simple ET que le parsing ne se trouve pas actuellement à l'intérieur de guillemets doubles. Cette condition respecte la règle Unix où les guillemets simples perdent leur signification spéciale lorsqu'ils sont protégés par des guillemets doubles. Si les conditions sont remplies, la fonction bascule l'état `*in_sq = !*in_sq` (entrant ou sortant du mode guillemets simples) et retourne 1 pour indiquer que ce guillemet doit être supprimé de la sortie.

La **gestion des guillemets doubles** suit une logique symétrique avec `if (c == '"' && !*in_sq)`, vérifiant que le caractère est un guillemet double ET que le parsing n'est pas dans un contexte de guillemets simples. Cette règle reflète le fait que les guillemets doubles sont traités littéralement lorsqu'ils sont protégés par des guillemets simples. Comme pour les guillemets simples, l'état est basculé avec `*in_dq = !*in_dq` et la fonction retourne 1 pour signaler la suppression.

Le **retour de 0** pour tous les autres caractères indique qu'ils doivent être préservés dans la chaîne de sortie. Cette valeur de retour binaire permet aux fonctions appelantes de distinguer facilement entre les caractères à supprimer (guillemets actifs) et ceux à conserver (caractères normaux ou guillemets protégés). Cette architecture respecte parfaitement la sémantique des shells Unix où les guillemets servent de délimiteurs qui sont consommés lors du parsing mais n'apparaissent pas dans les arguments finaux passés aux programmes.

Cette implémentation gère élégamment les **règles de protection mutuelle** des guillemets : les guillemets simples protègent tout leur contenu (y compris les guillemets doubles) contre l'interprétation, tandis que les guillemets doubles permettent certaines expansions (comme les variables) tout en protégeant les guillemets simples. Cette logique constitue un élément fondamental du système de parsing des arguments shell.

TOGGLE_QUOTE
Cette fonction `toggle_quotes()` implémente un **gestionnaire d'état de guillemets** qui met à jour les indicateurs de quotage lors du parsing de chaînes shell, gérant les règles de protection mutuelle entre guillemets simples et doubles selon les conventions Unix standard.

La fonction traite d'abord les **guillemets simples** avec `if (c == '\'' && !(*in_dq))`, vérifiant que le caractère est un guillemet simple ET que le parsing ne se trouve pas actuellement à l'intérieur de guillemets doubles. Cette condition respecte la règle fondamentale des shells Unix où les guillemets simples perdent leur signification spéciale lorsqu'ils sont protégés par des guillemets doubles. Si les conditions sont satisfaites, la fonction bascule l'état avec `*in_sq = !(*in_sq)`, alternant entre l'entrée et la sortie du mode guillemets simples.

La **gestion des guillemets doubles** utilise une logique symétrique avec `else if (c == '"' && !(*in_sq))`, vérifiant que le caractère est un guillemet double ET que le parsing n'est pas dans un contexte de guillemets simples. Cette règle reflète le principe que les guillemets doubles sont traités littéralement lorsqu'ils sont protégés par des guillemets simples. L'état est basculé avec `*in_dq = !(*in_dq)` pour gérer l'alternance entre l'ouverture et la fermeture des guillemets doubles.

Cette **architecture de protection mutuelle** implémente fidèlement la sémantique des shells Unix : les guillemets simples créent une zone de protection totale où aucun caractère spécial (y compris les guillemets doubles) n'est interprété, tandis que les guillemets doubles permettent certaines expansions (comme les variables `$`) tout en protégeant les guillemets simples contre l'interprétation. Cette fonction constitue un élément essentiel du système de parsing qui permet de déterminer quand les caractères spéciaux comme `$` doivent être traités littéralement ou subir une expansion, garantissant un comportement cohérent avec les shells standard lors du traitement des arguments quotés.
