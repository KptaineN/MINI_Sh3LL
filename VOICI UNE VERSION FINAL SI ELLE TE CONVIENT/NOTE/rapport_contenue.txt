MAIN
**point d'entrée** de minishell et suit une structure classique d'initialisation, exécution et nettoyage. Elle accepte les trois paramètres standards : `argc` (nombre d'arguments), `argv` (tableau des arguments) et `envp` (variables d'environnement).

La fonction commence par déclarer une variable `shell` de type `t_shell`, c'est a **structure principale** contenant toutes les données nécessaires au fonctionnement de ce minishell. Cette approche centralisée facilite la gestion de l'état global du programme.

La **validation des arguments** est stricte : le programme refuse tout argument supplémentaire avec la condition `if (argc != 1 || argv[1])`. Cette vérification garantit que le minishell se lance uniquement avec minishell sans paramètres, ce qui est concorde avec le comportement de bash en mode interactif.

L'**initialisation du shell** se fait via `start_shell(&shell, envp)`, qui reçoit l'adresse de la structure shell et les variables d'environnement. Si cette initialisation échoue-> le programme effectue un nettoyage partiel avec `free_env_list(shell.env)` avant de retourner un code d'erreur = gestion appropriée de la mémoire même en cas d'échec.

La **boucle principale** `looping(&shell)` représente le cœur du shell - c'est là que s'effectue la lecture des commandes, leur parsing et leur exécution. Une fois cette boucle terminée (généralement par une commande `exit`), le programme procède au **nettoyage complet** avec `free_minishell(&shell)` avant de retourner le code de sortie stocké dans `shell.exit_status`, permettant ainsi de propager correctement les codes d'erreur des commandes exécutées.

LOOPING
Cette fonction `looping` implémente la **boucle principale** de votre minishell, qui constitue le cœur de l'interface interactive du shell. Elle prend en paramètre un pointeur vers la structure `t_shell` qui contient toutes les données nécessaires au fonctionnement du shell.

La fonction utilise une **boucle infinie** `while (1)` qui ne se termine que dans des conditions spécifiques. À chaque itération, elle déclare deux variables locales : `in` pour stocker l'entrée utilisateur sous forme de chaîne de caractères, et `r` pour capturer le code de retour du traitement de cette entrée.

Le **cycle de lecture** commence par l'appel à `read_user_input()`, qui affiche le prompt du shell "ᕕ( ᐛ )ᕗ minishell$ " et attend une saisie utilisateur. Si cette fonction retourne `NULL` (condition `!in`), cela indique que l'utilisateur a tapé Ctrl+D (EOF), ce qui nous fai sortir proprement du shell via `break`.

Le **traitement de l'entrée** s'effectue ensuite avec `process_input(shell, in)`, qui parse et exécute la commande saisie. Cette fonction retourne un code d'état stocké dans `r`. Si ce code vaut `1`, cela indique une demande de sortie explicite (via la commande `exit`), déclenchant aussi un `break` pour terminer la boucle.

La fonction retourne systématiquement `0`,  un **arrêt normal** du shell. Cette architecture garantit que le shell reste actif jusqu'à ce qu'une condition de sortie soit rencontrée, offrant ainsi une expérience utilisateur fluide et prévisible typique des shells interactifs.

READ_USER_INPUT
Cette fonction `read_user_input` gère la **lecture interactive** des commandes utilisateur dans minishell. Elle utilise la bibliothèque GNU Readline, qui est le standard pour créer des interfaces en ligne de commande interactives avec des fonctionnalités avancées comme l'historique des commandes et l'édition de ligne.

La fonction commence par déclarer une variable locale `input` de type `char *` pour stocker la chaîne de caractères saisie par l'utilisateur. L'appel à `readline()` affiche le **prompt personnalisé** `"ᕕ( ᐛ )ᕗ minishell$ "` (qui inclut un emoticon amusant) et attend que l'utilisateur tape une commande suivie d'Entrée.

La **gestion de l'EOF** (End-of-File) est cruciale ici : si `readline()` retourne `NULL`, cela signifie que l'utilisateur a tapé Ctrl+D, qui est le signal standard Unix pour indiquer la fin d'entrée. Dans ce cas, la fonction écrit explicitement `"exit\n"` sur la sortie standard (descripteur 1) avec `write()` pour informer l'utilisateur que le shell va se fermer.

Un point important à noter est que `readline()` **alloue dynamiquement** la mémoire pour stocker l'entrée utilisateur. Cette mémoire devra être libérée avec `free()` ailleurs dans le code pour éviter les fuites mémoire. La fonction retourne soit un pointeur vers la chaîne saisie (qu'il faudra libérer), soit `NULL` en cas d'EOF, permettant au code appelant de déterminer s'il doit continuer ou arrêter la boucle principale du shell.

approche élégante car elle sépare clairement la responsabilité de lecture d'entrée du traitement des commandes, facilitant la maintenance et les tests du code.

PROCESS_INPUT
Cette fonction `process_input` constitue le **gestionnaire central** de traitement des commandes dans minishell, orchestrant tout le pipeline depuis la validation de l'entrée utilisateur jusqu'à l'exécution des processus.

La fonction commence par effectuer des **vérifications préliminaires** essentielles. Si l'entrée est vide (détectée par `is_line_empty`), elle nettoie immédiatement les ressources et retourne 0. Sinon, elle ajoute la commande à l'historique via `add_history()` pour permettre la navigation avec les flèches, puis vérifie si l'utilisateur souhaite quitter le shell avec `must_exit()`, auquel cas elle retourne 1 pour signaler à la boucle principale de se terminer.

L'**expansion des variables** constitue une étape cruciale avec `expand_input()`, qui traite probablement les variables d'environnement ($VAR) et autres expansions shell. Si cette expansion échoue (retourne NULL), la fonction nettoie et retourne 0, évitant ainsi de traiter une ligne corrompue.

Le **parsing et la préparation** s'effectuent via `parse_and_prepare()`, qui transforme la ligne en structures de données exploitables par le shell. Cette fonction peut retourner des codes d'erreur négatifs (-1 pour parsing, -2 pour allocation mémoire), auquel cas `process_input` effectue un nettoyage minutieux incluant la remise à NULL du pointeur `sh->input` et la libération de la mémoire d'entrée avant de propager l'erreur.

En cas de succès, la fonction appelle `launch_process()` pour **exécuter les commandes parsées**, puis procède au **nettoyage final** systématique : libération des ressources temporaires, remise à NULL du pointeur d'entrée, et libération de la chaîne d'entrée originale. Le retour de la valeur 2 semble indiquer une exécution réussie, permettant à la boucle principale de continuer normalement. Cette architecture garantit une gestion rigoureuse de la mémoire et une propagation claire des états d'erreur.

PARSE_AND_PREPARE
Cette fonction `parse_and_prepare` implémente la **phase de parsing et de préparation** de minishell, transformant une ligne de commande brute en structures de données exploitables pour l'exécution. Elle suit une approche séquentielle où chaque étape dépend du succès de la précédente.

La fonction commence par sauvegarder la ligne d'entrée dans `sh->input`, puis lance le **découpage lexical** avec `custom_split()`. Cette fonction personnalisée divise probablement la ligne en tokens en respectant les règles du shell (guillemets, échappements, espaces). Si le découpage échoue (retourne NULL), la fonction retourne immédiatement -1, indiquant une erreur de parsing qui peut survenir avec des commandes malformées ou des problèmes d'allocation mémoire.

Une fois les tokens obtenus, la fonction enchaîne plusieurs **étapes d'analyse sémantique** : `attribute_token_type()` classifie chaque token (commande, argument, opérateur), `assign_redirs()` identifie et traite les redirections (>, <, >>), et `build_cmd_list()` organise les tokens en commandes distinctes, particulièrement important pour gérer les pipes. L'appel à `ensure_fallback_cmd()` garantit qu'au moins une commande existe même si le parsing n'en a pas détecté.

La **préparation à l'exécution** se termine par l'allocation d'un tableau de PIDs avec `malloc(sizeof(pid_t) * sh->n_cmd)`. Ce tableau stockera les identifiants des processus enfants créés lors de l'exécution, un élément crucial pour la gestion des processus dans un shell avec support des pipes. Si cette allocation échoue, la fonction affiche une erreur avec `perror()`, nettoie les ressources déjà allouées via `cleanup_shell_iter()`, et retourne -2 pour distinguer cette erreur d'allocation des erreurs de parsing.

Le retour de 0 signale un succès complet, indiquant que toutes les structures sont prêtes pour l'étape d'exécution. Cette architecture modulaire facilite le débogage et permet une gestion d'erreur granulaire selon le type de problème rencontré.

ENSURE_FALLBACK_CMD
Cette fonction `ensure_fallback_cmd` implémente un **mécanisme de sécurité** crucial dans le parser de minishell pour gérer les cas où le parsing a produit des tokens mais n'a pas réussi à construire de commandes valides. Elle agit comme un filet de sécurité pour éviter les états incohérents dans la structure de données du shell.

La condition `if (sh->n_tokens > 0 && sh->n_cmd == 0)` détecte une **situation problématique** : le shell a réussi à tokeniser l'entrée utilisateur (il y a des tokens), mais le processus de construction des commandes n'a produit aucune commande exécutable. Cette situation peut survenir avec des entrées malformées ou des cas limites que le parser principal n'a pas su traiter correctement.

Lorsque cette condition est détectée, la fonction **crée artificiellement une commande** à partir du premier token disponible. Elle incrémente `sh->n_cmd` à 1, puis utilise `ft_lstnew()` pour créer un nouveau nœud de liste chaînée contenant l'adresse du premier token (`&sh->tokens[0]`). Cette approche transforme le premier token en commande par défaut, garantissant qu'il y aura toujours quelque chose à exécuter.

La **gestion d'erreur** est particulièrement stricte : si l'allocation du nœud échoue, la fonction affiche un message d'erreur avec `perror()` puis termine brutalement le programme avec `exit(1)`. Cette approche drastique indique que l'échec d'allocation à ce stade est considéré comme fatal, car le shell ne peut pas fonctionner sans pouvoir créer ses structures de données fondamentales.

Enfin, la fonction initialise les **pointeurs de liste** `cmd_head` et `cmd_tail` au même nœud, créant une liste d'un seul élément. Cette configuration permet au reste du système d'exécution de fonctionner normalement, même dans ce cas de fallback, en maintenant la cohérence des structures de données attendues par les fonctions d'exécution.

IS_LINE_EMPTY / MUST_EXIT
Ces deux fonctions utilitaires implémentent des **vérifications fondamentales** pour le traitement des entrées utilisateur dans minishell, utilisant des techniques de validation simples mais robustes.

La fonction `is_line_empty()` détecte les **entrées vides ou invalides** en utilisant une logique à deux niveaux. Elle retourne vrai si le pointeur `s` est NULL (entrée invalide) ou si le premier caractère de la chaîne est le terminateur `'\0'` (chaîne vide). Cette double vérification est une pratique défensive essentielle en C pour éviter les segfaults lors du déréférencement de pointeurs NULL. L'utilisation de l'opérateur logique `||` garantit une **évaluation paresseuse** : si `s` est NULL, la seconde condition ne sera pas évaluée, évitant ainsi un accès mémoire invalide.

La fonction `must_exit()` implémente la **détection de la commande de sortie** en comparant la chaîne d'entrée avec "exit" via `ft_strcmp()`. Cette fonction personnalisée (de la libft) retourne 0 quand les chaînes sont identiques, d'où la comparaison `== 0`. Cette approche est plus robuste qu'une simple vérification de longueur car elle garantit une correspondance exacte avec la commande exit standard des shells Unix.

Ces fonctions illustrent des **bonnes pratiques de programmation défensive** : elles sont courtes, ont une responsabilité unique, et gèrent les cas d'erreur de manière prévisible. Le mot-clé `static` indique qu'elles sont à usage interne du module, ce qui améliore l'encapsulation. Leur simplicité les rend facilement testables et réutilisables, constituant des briques de base fiables pour le système de validation des entrées de minoshell.

START_INIT
Ce code implémente la **séquence d'initialisation complète** de  minishell à travers trois fonctions qui se coordonnent pour préparer tous les composants nécessaires au fonctionnement du shell.

La fonction `init_idx()` se concentre sur l'**initialisation des structures de données internes** de votre shell. Elle commence par initialiser l'environnement via `init_env(envp)`, qui copie probablement les variables d'environnement du processus parent. Si cette initialisation échoue, le programme termine immédiatement avec `exit(EXIT_FAILURE)`, indiquant que l'environnement est critique pour le fonctionnement du shell. La fonction procède ensuite à l'initialisation systématique de tous les champs de la structure : les descripteurs de fichiers sont configurés sur les valeurs standard (`STDIN_FILENO`, `STDOUT_FILENO`), les compteurs sont mis à zéro, et tous les pointeurs sont initialisés à `NULL` pour éviter les accès à des zones mémoire non définies.

La fonction `init_shell()` agit comme un **orchestrateur de niveau supérieur** qui coordonne l'initialisation complète. Après avoir vérifié la validité des paramètres d'entrée, elle initialise les champs de base comme `args`, `exit_status` et `input`, puis délègue l'initialisation détaillée à `init_idx()`. L'appel final à `init_all_t_arr()` suggère l'initialisation d'autres structures de données spécialisées, probablement liées aux tableaux de tokens ou de commandes.

Enfin, `start_shell()` constitue le **point d'entrée principal** de l'initialisation du shell. Elle commence par vérifier la validité du pointeur shell, puis effectue une remise à zéro complète de la structure avec `ft_bzero()` pour garantir un état initial propre. L'appel dupliqué à `init_signals()` semble être une erreur de frappe, mais cette fonction configure probablement les gestionnaires de signaux pour Ctrl+C, Ctrl+Z, etc. La fonction retourne 1 en cas de succès et 0 en cas d'échec, permettant au code appelant de détecter les problèmes d'initialisation et de réagir en conséquence.

INIT_IDX
Cette fonction `init_idx()` implémente l'**initialisation systématique** de la structure principale `t_shell` de votre minishell, établissant un état initial cohérent et sûr pour tous les composants du shell.

La fonction commence par l'**initialisation critique de l'environnement** via `init_env(envp)`, qui copie et traite les variables d'environnement héritées du processus parent. L'échec de cette opération est considéré comme fatal - si `shell->env` est NULL, le programme affiche une erreur avec `perror()` et termine immédiatement avec `exit(EXIT_FAILURE)`. Cette approche stricte reflète l'importance des variables d'environnement pour le fonctionnement correct d'un shell Unix.

L'**initialisation des descripteurs de fichiers** suit avec `fd_in` et `fd_out` configurés respectivement sur `STDIN_FILENO` et `STDOUT_FILENO`. Ces valeurs par défaut garantissent que le shell commence avec les flux standards, pouvant être modifiés ultérieurement lors du traitement des redirections. Le pointeur `heredoc` est mis à NULL, indiquant qu'aucun document here n'est actuellement en cours de traitement.

La fonction procède ensuite à l'**initialisation des structures de parsing** en remettant à zéro les compteurs `n_tokens` et `n_cmd`, et en initialisant tous les pointeurs liés au parsing (`tokens`, `cmd_head`, `cmd_tail`, `parsed_args`, `bcmd`, `oper`) à NULL. Cette approche défensive évite les accès à des zones mémoire non initialisées et facilite les vérifications de validité dans le reste du code.

Enfin, l'**initialisation des structures d'exécution** termine la séquence avec `pids` mis à NULL (le tableau des PIDs sera alloué dynamiquement selon le nombre de commandes) et `fd_pid` initialisé à -1. L'utilisation de -1 pour les descripteurs de fichiers est une convention Unix standard indiquant qu'aucun fichier n'est ouvert, permettant aux fonctions ultérieures de détecter facilement les descripteurs valides versus non initialisés.

INIT_SHELL
Cette fonction `init_shell()` sert de **coordinateur principal** pour l'initialisation de votre structure shell, orchestrant une séquence d'initialisation en deux phases : les champs de base puis les structures complexes.

La fonction commence par une **validation défensive** des paramètres d'entrée avec `if (!shell || !envp)`. Cette vérification garantit que les pointeurs essentiels ne sont pas NULL avant de procéder à l'initialisation. Si l'un des paramètres est invalide, la fonction retourne immédiatement sans effectuer d'opération, évitant ainsi les segfaults et les comportements imprévisibles.

L'**initialisation des champs fondamentaux** suit avec trois assignations critiques : `args` est mis à NULL pour indiquer qu'aucun argument n'est actuellement stocké, `exit_status` est initialisé à 0 (succès par défaut selon les conventions Unix), et `input` est mis à NULL pour signaler qu'aucune entrée utilisateur n'est en cours de traitement. Ces initialisations établissent un état de base cohérent pour le shell.

La fonction délègue ensuite l'**initialisation approfondie** à deux fonctions spécialisées : `init_idx(shell, envp)` configure les structures internes complexes (environnement, descripteurs de fichiers, pointeurs de parsing) tandis que `init_all_t_arr(shell)` semble initialiser des tableaux spécialisés, probablement liés aux types de tokens ou aux structures de données auxiliaires.

Cette architecture modulaire sépare clairement les responsabilités : `init_shell()` gère l'orchestration et les vérifications de sécurité, tandis que les fonctions déléguées se concentrent sur leurs domaines spécifiques. Cette approche facilite la maintenance du code et permet une initialisation progressive et contrôlée de tous les composants du shell.

START_SHELL
Cette fonction `start_shell()` constitue le **point d'entrée principal** pour l'initialisation complète de votre minishell, orchestrant toute la séquence de démarrage du shell dans un ordre logique et sécurisé.

La fonction commence par une **validation essentielle** du paramètre d'entrée avec `if (!shell)`. Si le pointeur vers la structure shell est NULL, elle retourne immédiatement 0 pour signaler un échec d'initialisation. Cette vérification préventive évite les segfaults et permet au code appelant de détecter et gérer l'erreur appropriément.

L'**initialisation mémoire** suit avec `ft_bzero(shell, sizeof(t_shell))`, qui remet à zéro tous les octets de la structure shell. Cette opération garantit un état initial propre en éliminant toute donnée résiduelle qui pourrait être présente en mémoire, créant ainsi une base fiable pour l'initialisation subséquente. C'est une pratique défensive cruciale en C pour éviter les comportements imprévisibles dus à des données non initialisées.

Le code présente un **appel dupliqué** à `init_signals()`, ce qui semble être une erreur de frappe ou de copier-coller. Cette fonction configure probablement les gestionnaires de signaux pour des signaux comme SIGINT (Ctrl+C), SIGQUIT (Ctrl+\), et SIGTSTP (Ctrl+Z), qui sont essentiels pour le comportement correct d'un shell interactif. Un seul appel devrait suffire.

La fonction se termine par l'appel à `init_shell(shell, envp)` qui effectue l'**initialisation détaillée** de tous les composants du shell, puis retourne 1 pour indiquer un succès complet. Cette valeur de retour permet au code appelant (typiquement la fonction `main`) de vérifier que l'initialisation s'est déroulée correctement avant de lancer la boucle principale du shell.

SIGNAL
Ce code implémente un **système de gestion des signaux** sophistiqué pour votre minishell, avec des comportements différenciés selon le contexte d'exécution (shell interactif, processus parent, ou processus enfant).

La fonction `handle_sigint()` définit le **gestionnaire personnalisé pour SIGINT** (Ctrl+C). Elle utilise `(void)sig` pour éviter les warnings de paramètre non utilisé, puis écrit un saut de ligne sur stderr avec `write(2, "\n", 1)` pour maintenir un affichage propre. Les appels aux fonctions readline (`rl_replace_line`, `rl_on_new_line`, `rl_redisplay`) sont cruciaux : ils effacent la ligne courante, positionnent le curseur sur une nouvelle ligne, et rafraîchissent l'affichage du prompt. Cette séquence garantit que l'utilisateur retrouve un prompt propre après avoir tapé Ctrl+C, mimant le comportement de bash.

La fonction `init_signals()` configure les **gestionnaires par défaut du shell** en utilisant `sigaction()` pour un contrôle précis. Pour SIGINT, elle assigne le gestionnaire personnalisé avec le flag `SA_RESTART` qui permet aux appels système interrompus de reprendre automatiquement. Pour SIGQUIT (Ctrl+\), elle utilise `SIG_IGN` pour ignorer complètement le signal, ce qui est le comportement standard d'un shell interactif où seules les commandes en cours d'exécution doivent réagir à SIGQUIT.

La fonction `parent_signals()` implémente une **stratégie d'isolation** pour les processus parents pendant l'exécution de commandes. Elle ignore à la fois SIGINT et SIGQUIT avec `SIG_IGN`, empêchant ainsi le shell principal de se terminer quand l'utilisateur tape Ctrl+C ou Ctrl+\ pendant qu'une commande enfant s'exécute. Cette approche garantit que seuls les processus enfants reçoivent et traitent ces signaux.

Enfin, `child_signals()` restaure le **comportement par défaut** des signaux dans les processus enfants avec `SIG_DFL`. Cette restauration est essentielle car les processus enfants (commandes exécutées) doivent pouvoir être interrompus normalement par Ctrl+C ou Ctrl+\, contrairement au shell parent qui doit rester actif. Cette architecture à trois niveaux permet un contrôle fin des signaux selon le contexte d'exécution.

CHILD_SIGNALS
Cette fonction `child_signals()` implémente la **restauration des gestionnaires de signaux par défaut** dans les processus enfants de votre minishell, ce qui est une étape cruciale pour assurer un comportement correct des commandes exécutées.

La fonction utilise l'interface `signal()` pour réinitialiser deux signaux critiques : `SIGINT` (généré par Ctrl+C) et `SIGQUIT` (généré par Ctrl+\) avec la valeur `SIG_DFL`. Cette constante indique au système d'utiliser le **comportement par défaut** pour ces signaux, c'est-à-dire terminer le processus. Cette restauration est nécessaire car le processus parent (le shell) a configuré des gestionnaires personnalisés pour ces signaux afin de rester actif lors des interruptions utilisateur.

L'appel de cette fonction est typiquement effectué **après un `fork()` mais avant un `exec()`** dans le processus enfant. Sans cette restauration, les commandes exécutées hériteraient des gestionnaires de signaux du shell parent, ce qui signifierait qu'elles ne pourraient pas être interrompues normalement par Ctrl+C ou Ctrl+\. Par exemple, une commande comme `sleep 60` ne pourrait pas être arrêtée par l'utilisateur.

Cette approche illustre un principe fondamental de la programmation Unix : les **processus enfants héritent des gestionnaires de signaux** de leur parent, mais les commandes doivent pouvoir être contrôlées indépendamment du shell qui les lance. En restaurant `SIG_DFL`, votre minishell garantit que les programmes exécutés se comportent exactement comme s'ils étaient lancés depuis un shell standard, préservant ainsi l'expérience utilisateur attendue dans un environnement Unix.

PARENT_SIGNALS
Cette fonction `parent_signals()` implémente une **stratégie d'isolation des signaux** pour le processus parent (le shell) pendant l'exécution de commandes enfants, garantissant que seuls les processus enfants réagissent aux interruptions utilisateur.

La fonction configure deux structures `sigaction` distinctes pour gérer `SIGINT` (Ctrl+C) et `SIGQUIT` (Ctrl+\). Pour chaque signal, elle commence par initialiser proprement le masque de signaux avec `sigemptyset()`, qui vide le masque pour s'assurer qu'aucun autre signal ne sera bloqué pendant le traitement. Cette initialisation est une bonne pratique car les structures peuvent contenir des données résiduelles.

Le **comportement d'ignorance** est défini par `sa_int.sa_handler = SIG_IGN` et `sa_quit.sa_handler = SIG_IGN`. Cette configuration indique au système d'ignorer complètement ces signaux dans le processus parent. Le commentaire  suggère qu'une version précédente utilisait un gestionnaire personnalisé, mais la version actuelle préfère l'ignorance totale pour plus de simplicité.

Le flag `SA_RESTART` pour SIGINT est particulièrement important : il permet aux **appels système interrompus** de reprendre automatiquement au lieu de retourner une erreur `EINTR`. Cette fonctionnalité est cruciale pour maintenir la stabilité du shell pendant que des commandes s'exécutent en arrière-plan ou en premier plan.

Cette stratégie d'isolation garantit que lorsque l'utilisateur tape Ctrl+C pendant l'exécution d'une commande comme `ls -la`, seule la commande `ls` est interrompue, tandis que le shell parent reste actif et peut afficher un nouveau prompt. Sans cette protection, le shell lui-même pourrait se terminer de manière inattendue, créant une expérience utilisateur frustrante.

INIT_SIGNALS
Cette fonction `init_signals()` configure la **gestion des signaux par défaut** pour votre minishell en mode interactif, établissant les comportements appropriés pour les interruptions utilisateur les plus courantes.

La fonction utilise l'interface `sigaction()` plutôt que la fonction `signal()` plus simple, ce qui offre un **contrôle plus précis et portable** des gestionnaires de signaux. Elle déclare deux structures `sigaction` distinctes pour configurer séparément `SIGINT` (Ctrl+C) et `SIGQUIT` (Ctrl+\), permettant des comportements différenciés selon le type d'interruption.

Pour **SIGINT**, la configuration est sophistiquée : `sigemptyset()` initialise un masque vide (aucun signal bloqué pendant le traitement), `sa_handler` pointe vers la fonction personnalisée `handle_sigint` qui gère proprement l'interruption avec readline, et le flag `SA_RESTART` garantit que les appels système interrompus reprennent automatiquement. Cette approche permet au shell de réagir élégamment à Ctrl+C en affichant un nouveau prompt sans se terminer.

Pour **SIGQUIT**, la stratégie est différente : le gestionnaire est configuré sur `SIG_IGN` pour ignorer complètement ce signal, avec `sa_flags = 0` (pas de flags spéciaux). Cette configuration reflète le comportement standard des shells interactifs où Ctrl+\ ne doit pas affecter le shell lui-même, mais seulement les commandes en cours d'exécution.

L'activation finale via `sigaction(SIGINT, &sa_int, NULL)` et `sigaction(SIGQUIT, &sa_quit, NULL)` installe ces **gestionnaires dans le processus courant**. Cette configuration reste active pendant toute la durée de vie du shell interactif, mais sera modifiée temporairement par `parent_signals()` et `child_signals()` selon les contextes d'exécution, créant ainsi un système de gestion des signaux adaptatif et robuste.

HANDLE_SIGINT
Cette fonction `handle_sigint()` implémente un **gestionnaire de signal personnalisé** pour SIGINT (Ctrl+C) dans votre minishell, offrant une expérience utilisateur fluide et professionnelle lors des interruptions.

La fonction commence par `(void)sig` qui est une **technique d'évitement des warnings** du compilateur. Le paramètre `sig` contient le numéro du signal reçu (ici SIGINT), mais comme la fonction sait qu'elle ne traite que SIGINT, ce paramètre n'est pas utilisé. Le cast vers `void` indique explicitement au compilateur que l'omission est intentionnelle, évitant les warnings "unused parameter".

L'appel `write(2, "\n", 1)` effectue une **écriture directe sur stderr** (descripteur 2) pour afficher un saut de ligne. Cette approche utilise l'appel système `write()` plutôt que `printf()` car les fonctions de la famille printf ne sont pas **async-signal-safe**, c'est-à-dire qu'elles ne peuvent pas être appelées en sécurité depuis un gestionnaire de signal. L'utilisation de `write()` garantit un comportement prévisible même dans ce contexte critique.

La séquence finale avec les **fonctions readline** (`rl_replace_line`, `rl_on_new_line`, `rl_redisplay`) est cruciale pour maintenir l'intégrité de l'interface utilisateur. `rl_replace_line("", 0)` efface le contenu de la ligne courante, `rl_on_new_line()` positionne le curseur sur une nouvelle ligne, et `rl_redisplay()` rafraîchit l'affichage du prompt. Cette séquence garantit que l'utilisateur voit un prompt propre et fonctionnel après avoir tapé Ctrl+C, reproduisant fidèlement le comportement de bash et autres shells modernes.

T_ARR
Ce code implémente une **bibliothèque de manipulation de tableaux dynamiques** avec des fonctionnalités de recherche et de construction, utilisant une architecture basée sur des structures `t_arr` et `t_dic` pour gérer des collections de données.

La fonction `t_arrlen()` calcule la **longueur d'un tableau de pointeurs** en utilisant la convention NULL-terminated courante en C. Elle parcourt le tableau jusqu'à rencontrer un pointeur NULL qui marque la fin, retournant 0 si le tableau lui-même est NULL. Cette approche est similaire à `strlen()` mais pour des tableaux de pointeurs génériques.

Les fonctions de recherche `is_in_t_arr_str()` et `is_in_t_arr_dic_str()` implémentent deux **stratégies de correspondance différentes** dans un tableau de dictionnaires. La première effectue une **correspondance exacte** en utilisant `ft_strcmp()` pour trouver une clé identique à l'argument donné. La seconde réalise une **correspondance par préfixe** avec `ft_strncmp()`, ce qui permet de trouver des entrées dont la clé commence par l'argument fourni. Cette distinction est particulièrement utile pour des fonctionnalités comme l'autocomplétion ou la recherche de commandes par préfixe.

La fonction `build_t_arr_str()` implémente un **constructeur robuste** pour créer une structure `t_arr` à partir d'un tableau de chaînes. Elle utilise une approche défensive avec une **gestion d'erreur en cascade** : si l'allocation de la structure principale échoue, elle retourne immédiatement ; si l'allocation du tableau interne échoue, elle libère la structure ; si la duplication d'une chaîne échoue, elle nettoie toutes les ressources déjà allouées. Cette gestion rigoureuse de la mémoire évite les fuites même en cas d'échec partiel.

L'architecture générale révèle un **système de conteneur générique** où `t_arr` encapsule un tableau de pointeurs avec sa longueur, permettant un accès sécurisé et des opérations de recherche efficaces. L'utilisation de `t_dic` suggère une structure clé-valeur, typique des implémentations de variables d'environnement ou de tables de symboles dans un shell.

BUILD_T_ARR_STR
Cette fonction `build_t_arr_str()` implémente un **constructeur dynamique** pour créer une structure `t_arr` à partir d'un tableau de chaînes de caractères, en gérant méticuleusement l'allocation mémoire et la gestion d'erreurs.

La fonction utilise un **double pointeur** `t_arr **dst` comme paramètre, permettant de modifier le pointeur dans la fonction appelante. Elle commence par allouer la mémoire pour la structure principale avec `malloc(sizeof(t_arr))`. Si cette allocation échoue, la fonction retourne immédiatement, laissant `*dst` dans son état initial. Une fois l'allocation réussie, elle initialise le champ `len` avec la taille fournie.

La **seconde phase d'allocation** concerne le tableau interne `arr` qui stockera les pointeurs vers les chaînes copiées. L'allocation de `sizeof(char *) * len` crée un tableau de pointeurs de la taille appropriée. Si cette allocation échoue, la fonction démontre une **gestion d'erreur exemplaire** : elle libère la structure déjà allouée, remet le pointeur destination à NULL, et retourne. Cette approche évite les fuites mémoire même en cas d'échec partiel.

La **boucle de copie** constitue la phase la plus délicate où chaque chaîne du tableau source est dupliquée via `ft_strdup()`. Cette fonction alloue de la mémoire et copie le contenu de chaque chaîne, créant des copies indépendantes. Si une duplication échoue à n'importe quel moment, la fonction adopte une stratégie de **nettoyage drastique** : elle libère la structure principale et remet le pointeur à NULL, bien qu'elle ne libère pas les chaînes déjà dupliquées.

Cette implémentation révèle une approche **défensive mais imparfaite** de la gestion mémoire. Bien qu'elle évite les fuites de la structure principale, elle présente une faille : en cas d'échec lors de la duplication des chaînes, les chaînes déjà allouées ne sont pas libérées, créant une fuite mémoire potentielle. Une implémentation plus robuste devrait parcourir et libérer toutes les chaînes déjà dupliquées avant de nettoyer la structure.

IS_IN_T_ARR_DIC_STR
Cette fonction `is_in_t_arr_dic_str()` implémente une **recherche par correspondance de préfixe** dans un tableau de dictionnaires, permettant de trouver des entrées dont les clés commencent par une chaîne donnée.

La fonction commence par une **validation défensive** complète des paramètres d'entrée, vérifiant que le tableau `arr`, son contenu interne `arr->arr`, et l'argument de recherche `arg` ne sont pas NULL. Si l'un de ces éléments est invalide, elle retourne -1 pour signaler une erreur, évitant ainsi les segfaults potentiels lors des accès mémoire ultérieurs.

Le **parcours du tableau** s'effectue via une boucle while qui itère sur tous les éléments jusqu'à `arr->len`. À chaque itération, la fonction cast explicitement l'élément courant vers un pointeur `t_dic` avec `(t_dic *)arr->arr[i]`, suggérant que le tableau contient des pointeurs génériques vers des structures de dictionnaire. La vérification `if (!dic || !dic->key)` avec `continue` permet d'ignorer élégamment les entrées nulles ou corrompues sans interrompre la recherche.

La **logique de correspondance** constitue le cœur de la fonction : elle calcule d'abord la longueur de la clé du dictionnaire avec `ft_strlen(dic->key)`, puis utilise `ft_strncmp(dic->key, arg, len_key)` pour comparer uniquement les premiers `len_key` caractères. Cette approche permet une **correspondance par préfixe** où l'argument peut être plus court que la clé stockée. Par exemple, si la clé est "export" et l'argument est "exp", la fonction retournera une correspondance.

Cette stratégie de recherche est particulièrement utile dans le contexte d'un shell pour des fonctionnalités comme l'**autocomplétion de commandes** ou la recherche de variables d'environnement par préfixe. Le retour de l'index de l'élément trouvé permet au code appelant d'accéder directement à l'entrée correspondante, tandis que -1 indique qu'aucune correspondance n'a été trouvée.

IS_IN_T_ARR_STR
Cette fonction `is_in_t_arr_str()` implémente une **recherche par correspondance exacte** dans un tableau de dictionnaires, utilisant une approche d'arrêt anticipé pour optimiser les performances de recherche.

La fonction déclare quatre variables locales qui orchestrent la recherche : `i` comme compteur d'itération, `found` initialisé à -1 pour indiquer "non trouvé", `valid` comme flag booléen pour valider les entrées, et `dic` comme pointeur temporaire vers chaque dictionnaire examiné. Cette séparation claire des responsabilités rend le code plus lisible et maintenable.

La **validation défensive** avec `if (!arr || !arr->arr || !arg)` vérifie la validité de tous les paramètres critiques avant de procéder. Cette vérification en cascade garantit que le tableau existe, qu'il contient des données, et que l'argument de recherche n'est pas NULL. Le retour de -1 en cas d'échec établit une convention claire pour signaler les erreurs au code appelant.

La **boucle de recherche** utilise une condition composite `while (i < arr->len && found == -1)` qui combine la vérification des limites du tableau avec un **arrêt anticipé** dès qu'un élément est trouvé. À chaque itération, la fonction cast l'élément courant vers `t_dic*`, puis utilise une variable `valid` pour encapsuler la vérification de la validité du dictionnaire et de sa clé. Cette approche améliore la lisibilité par rapport à des conditions imbriquées complexes.

La **logique de correspondance** utilise `ft_strcmp()` pour une comparaison exacte entre la clé du dictionnaire et l'argument recherché. Contrairement à la fonction de recherche par préfixe, celle-ci exige une correspondance parfaite pour retourner l'index. L'incrémentation conditionnelle `if (found == -1) i++` évite d'incrémenter inutilement le compteur une fois l'élément trouvé, bien que cela soit techniquement redondant avec la condition de boucle. Cette fonction est particulièrement adaptée pour la recherche de commandes built-in ou de variables d'environnement spécifiques dans votre minishell.

T_ARRLEN
Cette fonction `t_arrlen()` implémente un **calculateur de longueur générique** pour des tableaux de pointeurs terminés par NULL, suivant une convention similaire à `strlen()` mais pour des collections de pointeurs plutôt que de caractères.

La fonction accepte un paramètre `void **arr`, qui est un **pointeur vers un tableau de pointeurs génériques**. Cette signature permet de travailler avec n'importe quel type de tableau de pointeurs (chaînes de caractères, structures, etc.) grâce au polymorphisme du type `void*`. Le type de retour `size_t` est approprié pour représenter des tailles, étant un type non signé spécialement conçu pour les opérations de dimensionnement en C.

La **validation défensive** avec `if (!arr)` vérifie immédiatement si le tableau passé en paramètre est NULL, retournant 0 dans ce cas. Cette vérification préventive évite les segfaults qui surviendraient lors de l'accès à un pointeur invalide dans la boucle suivante, démontrant une programmation robuste et sécurisée.

Le **parcours du tableau** s'effectue via une boucle while simple qui exploite la convention des **tableaux NULL-terminated**. La condition `while (arr[len])` continue tant que l'élément courant n'est pas NULL, ce qui indique la fin du tableau. Cette approche est courante en C pour les tableaux dynamiques où la taille n'est pas explicitement stockée, comme les tableaux `argv` ou `envp` dans les programmes C.

Cette fonction est particulièrement utile dans votre minishell pour déterminer la taille de collections comme les arguments de commandes, les variables d'environnement, ou tout autre tableau de pointeurs où vous devez connaître le nombre d'éléments avant de les traiter. L'implémentation est efficace avec une complexité O(n) et suit les conventions standard du C pour ce type d'utilitaire.

T_ARR_INIT
Ce code implémente un **système de tables de correspondance** (lookup tables) pour associer les opérateurs shell et les commandes built-in à leurs fonctions de traitement respectives, utilisant un pattern de dispatch basé sur des tableaux de pointeurs de fonctions.

La fonction `init_oper_t_arr()` configure la **table des opérateurs shell** en créant deux tableaux parallèles : `all_operators` contient les chaînes représentant chaque opérateur (heredoc `<<`, append `>>`, logiques `&&`/`||`, pipe `|`, redirections `<`/`>`), tandis que `operator_handlers` stocke les pointeurs vers les fonctions correspondantes. Cette architecture permet une **résolution dynamique** des opérateurs : quand le parser rencontre un `|`, il peut directement appeler `handle_pipe` sans utiliser de longues chaînes de conditions if/else.

De manière similaire, `init_builtins_t_arr()` établit la **table des commandes intégrées** du shell, associant les noms des built-ins (`echo`, `cd`, `pwd`, etc.) à leurs implémentations (`ft_echo`, `ft_cd`, `ft_pwd`, etc.). Cette approche est particulièrement élégante car elle centralise la définition des commandes disponibles et facilite l'ajout de nouvelles commandes built-in : il suffit d'ajouter l'entrée dans les deux tableaux parallèles.

La signature des pointeurs de fonctions `int (*handler)(t_shell *, char **)` révèle une **interface standardisée** : toutes les fonctions de traitement reçoivent une référence vers la structure shell et un tableau d'arguments, et retournent un entier (probablement un code de statut). Cette uniformité permet un traitement générique indépendamment du type de commande ou d'opérateur.

La fonction `init_all_t_arr()` orchestre l'**initialisation complète** en appelant les deux fonctions spécialisées. L'appel final à `build_t_arr_dic_str()` (visible dans les deux fonctions précédentes) construit probablement une structure de dictionnaire optimisée pour la recherche rapide, transformant ces tableaux statiques en structures dynamiques efficaces pour les opérations de lookup pendant l'exécution du shell. Cette architecture favorise la performance et la maintenabilité en séparant la définition des commandes de leur mécanisme de résolution.

BUILD_T_ARR_DIC_STR
Cette fonction `build_t_arr_dic_str()` implémente un **constructeur de dictionnaire spécialisé** qui crée une structure `t_arr` contenant des entrées de dictionnaire associant des clés string à des pointeurs de fonctions, constituant l'épine dorsale du système de dispatch de votre minishell.

La signature de la fonction révèle une architecture sophistiquée : elle accepte un double pointeur `t_arr **dst` pour modifier la destination, un tableau de clés `char **keys`, un tableau de pointeurs de fonctions `int (**values)(t_shell *, char **)` avec une signature standardisée pour toutes les commandes/opérateurs, et la longueur `len` des tableaux. Cette approche permet de construire dynamiquement des tables de correspondance entre chaînes de caractères et fonctions de traitement.

La fonction commence par l'**allocation de la structure principale** via `alloc_t_arr(dst, len)`, qui prépare probablement l'espace nécessaire pour stocker `len` pointeurs vers des dictionnaires. Si cette allocation échoue (retour < 0), la fonction se termine immédiatement, évitant toute allocation partielle qui pourrait créer des fuites mémoire.

La **boucle de construction** itère sur chaque paire clé-valeur, initialisant `dic` à NULL avant chaque création d'entrée. L'appel à `make_dic_entry(&dic, keys[i], values[i])` construit une entrée de dictionnaire associant la clé courante à sa fonction de traitement correspondante. La **gestion d'erreur robuste** est particulièrement notable : si la création d'une entrée échoue, la fonction appelle `free_dic_partial(dst, i)` qui libère toutes les entrées déjà allouées (indices 0 à i-1), évitant ainsi les fuites mémoire en cas d'échec partiel.

Cette architecture permet à votre minishell de résoudre efficacement les commandes et opérateurs : lors du parsing, il suffit de chercher une chaîne dans le dictionnaire pour obtenir directement le pointeur vers la fonction de traitement appropriée, éliminant le besoin de longues chaînes if/else et facilitant l'ajout de nouvelles fonctionnalités.

MAKE_DIC_ENTRY
Cette fonction `make_dic_entry()` implémente un **constructeur d'entrée de dictionnaire** qui crée une association clé-valeur entre une chaîne de caractères et un pointeur de fonction, constituant un élément fondamental du système de dispatch de votre minishell.

La fonction utilise un **double pointeur** `t_dic **out` comme paramètre de sortie, permettant de modifier le pointeur dans la fonction appelante. Elle accepte également une clé sous forme de chaîne constante et un pointeur vers une fonction avec la signature standardisée `int (*fn)(t_shell *, char **)`, garantissant que toutes les fonctions de commandes et d'opérateurs suivent la même interface.

L'**allocation et la gestion d'erreur** suivent une approche défensive rigoureuse. La fonction commence par allouer la mémoire pour la structure `t_dic` avec `malloc(sizeof(t_dic))`. Si cette allocation échoue, elle retourne immédiatement -1 pour signaler l'erreur. Cette vérification précoce évite toute opération sur un pointeur invalide.

La **duplication de la clé** avec `ft_strdup(key)` est cruciale car elle crée une copie indépendante de la chaîne fournie. Cette approche garantit que le dictionnaire possède sa propre copie de la clé, évitant les problèmes de durée de vie si la chaîne originale est libérée ailleurs. Si la duplication échoue, la fonction démontre une **gestion d'erreur exemplaire** en libérant la structure déjà allouée avec `free(dic)` avant de retourner -1, prévenant ainsi les fuites mémoire.

L'**assemblage final** de l'entrée assigne la clé dupliquée à `dic->key` et cast le pointeur de fonction vers `void *` pour `dic->value`, suggérant que la structure `t_dic` utilise un type générique pour stocker différents types de valeurs. L'affectation `*out = dic` transfère la propriété de la structure nouvellement créée au code appelant, et le retour de 0 signale un succès complet. Cette fonction encapsule parfaitement la création d'une entrée de dictionnaire avec une gestion robuste des erreurs et de la mémoire.

ALLOC_T_ARR
Cette fonction `alloc_t_arr()` implémente un **allocateur de structure de tableau dynamique** qui crée et initialise une structure `t_arr` capable de contenir un nombre spécifié de pointeurs vers des dictionnaires, constituant la fondation du système de tables de correspondance de votre minishell.

La fonction utilise un **double pointeur** `t_arr **dst` pour modifier directement le pointeur dans la fonction appelante, permettant d'allouer et d'initialiser la structure en une seule opération. Elle commence par allouer la mémoire pour la structure principale avec `malloc(sizeof(t_arr))`. Si cette allocation échoue, la fonction retourne immédiatement -1, signalant l'échec au code appelant sans effectuer d'opérations supplémentaires.

Une fois la structure principale allouée avec succès, la fonction initialise le champ `len` avec la taille fournie, puis procède à l'**allocation du tableau interne** avec `malloc(sizeof(t_dic *) * len)`. Cette allocation crée un tableau de pointeurs vers des structures `t_dic`, permettant de stocker les entrées de dictionnaire. La taille de chaque élément est `sizeof(t_dic *)` car le tableau stocke des pointeurs, pas les structures elles-mêmes.

La **gestion d'erreur robuste** est particulièrement bien implémentée : si l'allocation du tableau interne échoue, la fonction effectue un nettoyage complet en libérant la structure principale déjà allouée avec `free(*dst)`, puis remet le pointeur destination à NULL avec `*dst = NULL`. Cette approche garantit qu'en cas d'échec partiel, aucune fuite mémoire ne survient et que le pointeur destination reste dans un état cohérent (NULL).

Le retour de 0 en cas de succès établit une convention claire : les valeurs négatives indiquent des erreurs, tandis que 0 signale une allocation réussie. Cette fonction encapsule parfaitement l'allocation à deux niveaux nécessaire pour créer une structure de tableau dynamique, avec une gestion d'erreur qui maintient l'intégrité de la mémoire même en cas d'échec partiel.

FREE_DIC_PARTIAL
Cette fonction `free_dic_partial()` implémente un **mécanisme de nettoyage partiel** pour libérer proprement la mémoire d'une structure `t_arr` et de ses entrées de dictionnaire associées, particulièrement utile en cas d'échec d'allocation lors de la construction d'un tableau de dictionnaires.

La fonction utilise un **double pointeur** `t_arr **dst` pour pouvoir modifier le pointeur dans la fonction appelante et le remettre à NULL après libération. Le paramètre `upto` spécifie le nombre d'entrées à libérer, permettant un nettoyage partiel lorsque seules les premières entrées ont été allouées avec succès. Cette approche est cruciale pour éviter les fuites mémoire lors d'échecs d'allocation en cascade.

La **validation défensive** avec `if (!dst || !*dst || !(*dst)->arr)` vérifie tous les niveaux de pointeurs avant de procéder. Cette vérification en cascade garantit que la fonction peut être appelée en sécurité même si certaines allocations ont échoué, évitant les segfaults lors du déréférencement de pointeurs invalides.

La **boucle de libération** parcourt les `upto` premières entrées du tableau, castant chaque élément vers `t_dic *` et vérifiant sa validité avant libération. Pour chaque entrée valide, elle libère d'abord la clé dupliquée avec `free(d->key)`, puis la structure du dictionnaire elle-même avec `free(d)`. Cette approche respecte l'ordre inverse d'allocation et évite les fuites des chaînes de caractères dupliquées.

Le **nettoyage final** libère le tableau de pointeurs avec `free((*dst)->arr)`, puis la structure principale avec `free(*dst)`, et remet le pointeur destination à NULL avec `*dst = NULL`. Cette séquence garantit une libération complète et cohérente, laissant la variable appelante dans un état sûr (NULL) qui peut être détecté par d'autres parties du code pour éviter les doubles libérations.

FREE_ENV_LIST
Cette fonction `free_env_list()` implémente un **destructeur de liste chaînée** spécialisé pour libérer proprement une liste de variables d'environnement, en gérant la désallocation de tous les niveaux de structures imbriquées.

La fonction utilise une approche de **parcours sécurisé** en sauvegardant le pointeur vers le nœud suivant avec `next = lst->next` avant de commencer la libération du nœud courant. Cette technique est essentielle dans la libération de listes chaînées car l'accès à `lst->next` devient impossible après avoir libéré la mémoire de `lst`. Sans cette sauvegarde, la fonction provoquerait un comportement indéfini en tentant d'accéder à de la mémoire déjà libérée.

Le **déballage et la libération du contenu** s'effectuent via le cast `(t_env *)lst->content`, qui extrait la structure d'environnement stockée dans le nœud générique `t_list`. La vérification `if (e)` protège contre les nœuds contenant des pointeurs NULL, permettant à la fonction de gérer des listes partiellement initialisées ou corrompues. Pour chaque structure `t_env` valide, la fonction libère d'abord les chaînes `key` et `value` avec `free()`, puis la structure elle-même.

La **séquence de libération** respecte un ordre logique : elle commence par libérer les données les plus profondes (les chaînes de caractères), puis remonte vers les structures contenantes (la structure `t_env`), et termine par le nœud de liste lui-même. Cette approche en "pelures d'oignon" garantit qu'aucune référence n'est perdue avant libération et évite les fuites mémoire.

L'**avancement sécurisé** `lst = next` utilise la valeur sauvegardée pour passer au nœud suivant, permettant à la boucle `while (lst)` de continuer jusqu'à atteindre la fin de la liste (NULL). Cette implémentation est robuste et peut gérer des listes de n'importe quelle taille, y compris des listes vides, sans provoquer d'erreurs d'accès mémoire.


