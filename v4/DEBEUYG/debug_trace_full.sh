#!/bin/bash
set -euo pipefail

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Vérifier dépendances (ne bloque pas si manquantes, mais avertit)
for cmd in valgrind gdb readelf jq; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        echo -e "${YELLOW}⚠️  Attention : '$cmd' n'est pas installé. Pour un diagnostic complet installe-le.${NC}"
    fi
done

if [ $# -lt 2 ]; then
    echo "Usage: $0 <exécutable> <fichier_d'entrée> [--] [args...]"
    echo "Exemple: $0 ./minishell input.txt"
    exit 1
fi

EXE="$1"
INPUT="$2"
shift 2
EXTRA_ARGS=("$@")

if [ ! -x "$EXE" ]; then
    echo -e "${RED}Erreur : '$EXE' n'est pas exécutable ou n'existe pas.${NC}"
    exit 1
fi

if [ ! -f "$INPUT" ]; then
    echo -e "${YELLOW}⚠️  Fichier d'entrée '$INPUT' introuvable.${NC}"
    read -r -p "Créer un test minimal automatiquement ? [Y/n] " resp
    resp=${resp:-Y}
    if [[ "$resp" =~ ^[Yy]$ ]]; then
        cat > "$INPUT" <<EOF
pwd
echo autogenerated test
exit
EOF
        echo -e "${GREEN}Fichier '$INPUT' créé.${NC}"
    else
        echo -e "${RED}Abandon.${NC}"
        exit 1
    fi
fi

# Vérifier les symboles de debug
has_debug=false
if command -v readelf >/dev/null 2>&1 && readelf --sections "$EXE" | grep -q "\.debug_info"; then
    echo -e "${GREEN}✅ Debug symbols détectés dans l'exécutable.${NC}"
    has_debug=true
else
    echo -e "${YELLOW}⚠️  L'exécutable semble ne pas contenir de symboles de debug. Recompile avec '-g -O0'.${NC}"
fi

# Préparation des logs et sorties
mkdir -p .debug_combined
VG_LOG=".debug_combined/valgrind.log"
GDB_LOG=".debug_combined/gdb_combined.log"
SUMMARY_JSON="summary.json"
REPORT_HTML="report.html"

echo -e "\n${BLUE}=== 1. Lancement de Valgrind ===${NC}"
valgrind --tool=memcheck \
         --leak-check=full \
         --show-leak-kinds=all \
         --track-origins=yes \
         --verbose \
         --log-file="$VG_LOG" \
         timeout 15s "$EXE" < "$INPUT" "${EXTRA_ARGS[@]}" >/dev/null 2>&1 || true

echo -e "\n${BLUE}=== 2. Extraction d'un emplacement suspect ===${NC}"
suspect_location=""
if [ -f "$VG_LOG" ]; then
    ERR_BLOCK=$(awk '
        /Invalid read|Invalid write|Conditional jump/ {flag=1}
        flag {print}
        /^$/ && flag {exit}
    ' "$VG_LOG" | head -n 80)

    if echo "$ERR_BLOCK" | grep -qE " at [^:]+:[0-9]+"; then
        suspect_location=$(echo "$ERR_BLOCK" | grep -oE "[^ ]+:[0-9]+" | head -n1)
        echo -e "${GREEN}Localisation suspecte extraite : ${suspect_location}${NC}"
    else
        func=$(echo "$ERR_BLOCK" | grep -oE "[a-zA-Z_][a-zA-Z0-9_]* *\(" | head -n1 | sed 's/ *(//')
        if [ -n "$func" ]; then
            suspect_location="$func"
            echo -e "${GREEN}Fonction suspecte extraite : ${suspect_location}${NC}"
        else
            echo -e "${YELLOW}⚠️  Aucun emplacement précis extrait.${NC}"
        fi
    fi
else
    echo -e "${RED}Pas de log Valgrind trouvé: $VG_LOG${NC}"
fi

echo -e "\n${BLUE}=== 3. Génération & exécution GDB ===${NC}"
GDB_SCRIPT=".debug_combined/gdb_script.gdb"
cat > "$GDB_SCRIPT" <<EOF
set pagination off
set logging file $GDB_LOG
set logging enabled on
EOF

if [ -n "$suspect_location" ]; then
    if [[ "$suspect_location" =~ :[0-9]+$ ]]; then
        file=\${suspect_location%%:*}
        line=\${suspect_location##*:}
        echo "break ${suspect_location}" >> "$GDB_SCRIPT"
    else
        echo "break ${suspect_location}" >> "$GDB_SCRIPT"
    fi
else
    echo "break main" >> "$GDB_SCRIPT"
fi

cat >> "$GDB_SCRIPT" <<EOF
run < $INPUT

echo "\n=== Backtrace complète ===\n"
backtrace full
echo "\n=== Variables locales ===\n"
info locals
echo "\n=== Registres ===\n"
info registers
echo "\n=== Disassembly autour du PC ===\n"
x/20i \$pc

echo "\n=== Stepi (5 instructions) ===\n"
set \$__steps = 5
while \$__steps > 0
  stepi
  info registers
  set \$__steps = \$__steps - 1
end

quit
EOF

gdb -batch -x "$GDB_SCRIPT" "$EXE" 2>&1 || true

echo -e "\n${BLUE}=== 4. Construction du résumé JSON ===${NC}"
segfault_detected=false
if [ -f "$GDB_LOG" ] && grep -qE "Program received signal SIGSEGV|Segmentation fault" "$GDB_LOG"; then
    segfault_detected=true
fi

memory_errors=false
memory_leaks=false
if [ -f "$VG_LOG" ]; then
    if grep -qE "Invalid read|Invalid write|Conditional jump" "$VG_LOG"; then
        memory_errors=true
    fi
    if grep -qE "definitely lost.*[1-9]" "$VG_LOG"; then
        memory_leaks=true
    fi
fi

simple_exit_code=0
if ! timeout 5s "$EXE" < "$INPUT" >/dev/null 2>&1; then
    simple_exit_code=$?
fi

timestamp=$(date --iso-8601=seconds)
tester_summary="N/A"
tester_status="skipped"

if command -v jq >/dev/null 2>&1; then
    jq -n \
      --arg ts "$timestamp" \
      --arg compilation "unknown" \
      --argjson simple_exit_code "$simple_exit_code" \
      --argjson simple_segfault "$segfault_detected" \
      --arg suspect_location "$suspect_location" \
      --argjson segfault_detected "$segfault_detected" \
      --argjson memory_errors "$memory_errors" \
      --argjson memory_leaks "$memory_leaks" \
      --arg tester_summary "$tester_summary" \
      --arg tester_status "$tester_status" \
      '{
        timestamp: $ts,
        compilation: $compilation,
        simple_test: {
          exit_code: $simple_exit_code,
          segfault: $simple_segfault
        },
        suspect_location: $suspect_location,
        gdb: {
          segfault_detected: $segfault_detected
        },
        valgrind: {
          memory_errors: $memory_errors,
          memory_leaks: $memory_leaks
        },
        minishell_tester: {
          summary: $tester_summary,
          status: $tester_status
        }
      }' > "$SUMMARY_JSON"
else
    cat > "$SUMMARY_JSON" <<EOF
{
  "timestamp": "$timestamp",
  "simple_test": {
    "exit_code": $simple_exit_code,
    "segfault": $segfault_detected
  },
  "suspect_location": "$suspect_location",
  "gdb": {
    "segfault_detected": $segfault_detected
  },
  "valgrind": {
    "memory_errors": $memory_errors,
    "memory_leaks": $memory_leaks
  },
  "minishell_tester": {
    "summary": "$tester_summary",
    "status": "$tester_status"
  }
}
EOF
fi

echo -e "${GREEN}Résumé JSON écrit dans $SUMMARY_JSON${NC}"

echo -e "\n${BLUE}=== 5. Génération du rapport HTML ===${NC}"
if command -v jq >/dev/null 2>&1; then
    simple_code=$(jq '.simple_test.exit_code' "$SUMMARY_JSON")
    simple_segfault=$(jq '.simple_test.segfault' "$SUMMARY_JSON")
    val_errors=$(jq '.valgrind.memory_errors' "$SUMMARY_JSON")
    val_leaks=$(jq '.valgrind.memory_leaks' "$SUMMARY_JSON")
    suspect_loc=$(jq -r '.suspect_location' "$SUMMARY_JSON")
    gdb_seg=$(jq '.gdb.segfault_detected' "$SUMMARY_JSON")
else
    simple_code=$(grep -Po '"exit_code":\s*\K[0-9]+' "$SUMMARY_JSON" | head -1 || echo 0)
    simple_segfault=$(grep -Po '"segfault":\s*\K(true|false)' "$SUMMARY_JSON" | head -1 || echo false)
    val_errors=$(grep -Po '"memory_errors":\s*\K(true|false)' "$SUMMARY_JSON" | head -1 || echo false)
    val_leaks=$(grep -Po '"memory_leaks":\s*\K(true|false)' "$SUMMARY_JSON" | head -1 || echo false)
    suspect_loc=$(grep -Po '"suspect_location":\s*"\K[^"]+' "$SUMMARY_JSON" | head -1 || echo "")
    gdb_seg=$(grep -Po '"segfault_detected":\s*\K(true|false)' "$SUMMARY_JSON" | head -1 || echo false)
fi

cat > "$REPORT_HTML" <<EOF
<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<title>Rapport Debug Combiné</title>
<style>
  body { font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif; padding: 1rem; background:#f0f2f5; }
  h1 { margin-top:0; }
  .card { background:white; border-radius:8px; padding:1rem; margin-bottom:1rem; box-shadow:0 4px 12px rgba(0,0,0,0.08); }
  .ok { color: green; font-weight:bold; }
  .warn { color: darkorange; font-weight:bold; }
  .fail { color: red; font-weight:bold; }
  pre { background:#1e1e1e; color:#f5f5f5; padding:0.5rem; overflow:auto; border-radius:4px; }
  summary { font-size:1.1rem; }
  small { color:#555; }
</style>
</head>
<body>
  <h1>Rapport de débogage combiné</h1>
  <p>Généré le <strong>$(date --iso-8601=seconds)</strong></p>

  <div class="card">
    <details open>
      <summary><strong>Test simple</strong></summary>
      <p>Exit code: <span class="$( [ "$simple_code" -eq 0 ] && echo ok || echo fail )">$simple_code</span></p>
      <p>Segfault détecté: <span class="$( [ "$simple_segfault" = "true" ] && echo fail || echo ok )">$simple_segfault</span></p>
    </details>
  </div>

  <div class="card">
    <details>
      <summary><strong>Valgrind</strong></summary>
      <p>Erreurs mémoire: <span class="$( [ "$val_errors" = "true" ] && echo fail || echo ok )">$val_errors</span></p>
      <p>Fuites mémoire: <span class="$( [ "$val_leaks" = "true" ] && echo warn || echo ok )">$val_leaks</span></p>
      <pre>Extrait initial:
$(if [ -f "$VG_LOG" ]; then awk '/Invalid read|Invalid write|Conditional jump/{flag=1} flag{print} /^$/{if(flag){exit}}' "$VG_LOG" | head -n 30 | sed 's/&/&amp;/g; s/</\\u003c/g;'; else echo "Pas de log Valgrind"; fi)
      </pre>
    </details>
  </div>

  <div class="card">
    <details>
      <summary><strong>GDB</strong></summary>
      <p>Segfault détecté: <span class="$( [ "$gdb_seg" = "true" ] && echo fail || echo ok )">$gdb_seg</span></p>
      <p>Localisation suspecte: <code>$suspect_loc</code></p>
      <pre>$(if [ -f "$GDB_LOG" ]; then grep -E "Program received signal|#0|#1|#2|#3" "$GDB_LOG" | head -n 30 | sed 's/&/&amp;/g; s/</\\u003c/g;'; else echo "Pas de log GDB"; fi)</pre>
      <p><small>Voir le fichier complet: <code>$GDB_LOG</code></small></p>
    </details>
  </div>

  <div class="card">
    <details>
      <summary><strong>Résumé</strong></summary>
      <ul>
        <li>Suspect location : <code>$suspect_loc</code></li>
        <li>Segfault global: <span class="$( [ "$segfault_detected" = true ] && echo fail || echo ok )">$segfault_detected</span></li>
        <li>Erreurs mémoire: <span class="$( [ "$memory_errors" = true ] && echo fail || echo ok )">$memory_errors</span></li>
        <li>Fuites mémoire: <span class="$( [ "$memory_leaks" = true ] && echo warn || echo ok )">$memory_leaks</span></li>
      </ul>
    </details>
  </div>

  <div class="card">
    <details>
      <summary><strong>Logs bruts</strong></summary>
      <p>Valgrind: <code>$VG_LOG</code></p>
      <p>GDB: <code>$GDB_LOG</code></p>
      <p>Résumé machine: <code>$SUMMARY_JSON</code></p>
    </details>
  </div>
</body>
</html>
EOF

echo -e "${GREEN}Rapport HTML généré dans $REPORT_HTML${NC}"

echo -e "\n${BLUE}=== Synthèse ===${NC}"
echo "Suspect location: ${suspect_location:-(aucune)}"
echo "Segfault détecté par GDB : $segfault_detected"
echo "Erreurs mémoire : $memory_errors"
echo "Fuites mémoire : $memory_leaks"
echo -e "\nFichiers produits :"
echo "  - $VG_LOG"
echo "  - $GDB_LOG"
echo "  - $SUMMARY_JSON"
echo "  - $REPORT_HTML"

echo -e "\n${GREEN}✅ Analyse terminée.${NC}"
echo "Ouvre le rapport avec : xdg-open $REPORT_HTML"
