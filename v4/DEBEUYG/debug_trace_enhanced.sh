#!/bin/bash
# debug_trace_enhanced.sh
# Usage: ./debug_trace_enhanced.sh <ex√©cutable> <fichier_d'entr√©e> [--] [args...]
# Extrait automatiquement les probl√®mes m√©moire / segfault, fait du GDB cibl√©, ouvre session interactive si crash,
# et produit summary.json + report.html

# Ne pas aborter compl√®tement pour que les rapports soient toujours √©crits
set -u

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# V√©rifier minimalement les arguments
if [ $# -lt 2 ]; then
  echo -e "${RED}Usage: $0 <ex√©cutable> <fichier_d'entr√©e> [--] [args...]${NC}"
  exit 1
fi

EXE="$1"
INPUT="$2"
shift 2
EXTRA_ARGS=("$@")

# V√©rifications de base
if [ ! -x "$EXE" ]; then
  echo -e "${RED}Erreur: '$EXE' n'est pas ex√©cutable ou n'existe pas.${NC}"
  exit 1
fi

if [ ! -f "$INPUT" ]; then
  echo -e "${YELLOW}‚ö†Ô∏è  Fichier d'entr√©e '$INPUT' introuvable.${NC}"
  read -r -p "Cr√©er un test minimal automatiquement ? [Y/n] " resp
  resp=${resp:-Y}
  if [[ "$resp" =~ ^[Yy]$ ]]; then
    cat > "$INPUT" <<EOF
pwd
echo autogenerated test
exit
EOF
    echo -e "${GREEN}Fichier '$INPUT' cr√©√©.${NC}"
  else
    echo -e "${RED}Abandon.${NC}"
    exit 1
  fi
fi

# Dossiers / noms
mkdir -p .debug_combined
VG_LOG=".debug_combined/valgrind.log"
GDB_LOG=".debug_combined/gdb_combined.log"
GDB_SCRIPT=".debug_combined/gdb_script.gdb"
SUMMARY_JSON="summary.json"
REPORT_HTML="report.html"

# Info sur debug symbols
has_debug=false
if command -v readelf >/dev/null 2>&1 && readelf --sections "$EXE" | grep -q "\.debug_info"; then
  echo -e "${GREEN}‚úÖ Debug symbols d√©tect√©s dans '$EXE'.${NC}"
  has_debug=true
else
  echo -e "${YELLOW}‚ö†Ô∏è  Pas (ou peu) de symboles de debug. Recompile avec '-g -O0' pour des diagnostics plus pr√©cis.${NC}"
fi

echo -e "\n${BLUE}=== 1. Lancement de Valgrind (d√©tection m√©moire) ===${NC}"
# Lancer Valgrind (ne fait pas √©chouer le script)
if command -v valgrind >/dev/null 2>&1; then
  valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all \
           --track-origins=yes --verbose --log-file="$VG_LOG" \
           timeout 15s "$EXE" < "$INPUT" "${EXTRA_ARGS[@]}" >/dev/null 2>&1 || true
else
  echo -e "${YELLOW}valgrind non trouv√© : saut de la partie m√©moire.${NC}"
  echo "" > "$VG_LOG"
fi

echo -e "\n${BLUE}=== 2. Extraction automatique de 'suspect_location' depuis Valgrind ===${NC}"
suspect_location=""
if [ -f "$VG_LOG" ] && grep -qE "Invalid read|Invalid write|Conditional jump" "$VG_LOG"; then
  # extraire la premi√®re occurrence avec fichier:ligne
  suspect_location=$(awk '
    /Invalid read|Invalid write|Conditional jump/ {flag=1}
    flag && /at [^:]+:[0-9]+/ {
      match($0, /at ([^:]+:[0-9]+)/, a)
      if (a[1]) { print a[1]; exit }
    }
  ' "$VG_LOG")
  if [ -n "$suspect_location" ]; then
    echo -e "${GREEN}Localisation suspecte extraite : ${suspect_location}${NC}"
  else
    # fallback : extraire nom de fonction heuristique
    func=$(awk '
      /Invalid read|Invalid write|Conditional jump/ {flag=1}
      flag {
        if (match($0, /[a-zA-Z_][a-zA-Z0-9_]*\(/)) {
          print substr($0, RSTART, RLENGTH)
          exit
        }
      }
    ' "$VG_LOG" | sed 's/[(]$//')
    if [ -n "$func" ]; then
      suspect_location="$func"
      echo -e "${GREEN}Fonction suspecte extraite : ${suspect_location}${NC}"
    else
      echo -e "${YELLOW}Aucune localisation pr√©cise trouv√©e dans Valgrind.${NC}"
    fi
  fi
else
  echo -e "${YELLOW}Pas d'erreur m√©moire critique d√©tect√©e par Valgrind.${NC}"
fi

echo -e "\n${BLUE}=== 3. G√©n√©ration et ex√©cution du script GDB ===${NC}"
# Construire script GDB cibl√©
cat > "$GDB_SCRIPT" <<EOF
set pagination off
set logging file $GDB_LOG
set logging enabled on
EOF

if [ -n "$suspect_location" ]; then
  echo "break $suspect_location" >> "$GDB_SCRIPT"
else
  echo "break main" >> "$GDB_SCRIPT"
fi

cat >> "$GDB_SCRIPT" <<EOF
run < $INPUT
echo "\\n=== Backtrace compl√®te ===\\n"
backtrace full
echo "\\n=== Variables locales ===\\n"
info locals
echo "\\n=== Registres ===\\n"
info registers
echo "\\n=== Disassembly autour du PC ===\\n"
x/10i \$pc
quit
EOF

# Ex√©cution batch pour r√©cup√©rer le contexte
if command -v gdb >/dev/null 2>&1; then
  gdb -batch -x "$GDB_SCRIPT" "$EXE" >/dev/null 2>&1 || true
else
  echo -e "${YELLOW}gdb non trouv√©, impossible de faire l'analyse interactive.${NC}"
  echo "" > "$GDB_LOG"
fi

# D√©tection de segfault pour √©ventuellement ouvrir interactive
segfault_detected=false
if grep -qE "Program received signal SIGSEGV|Segmentation fault" "$GDB_LOG" 2>/dev/null; then
  segfault_detected=true
  echo -e "${RED}üö® Segfault d√©tect√© dans le log GDB.${NC}"
  # Si c'est un terminal interactif, ouvrir session GDB (pas en pipeline)
  if [ -t 1 ]; then
    echo -e "${BLUE}Ouverture d'une session GDB interactive pour investigation...${NC}"
    if [ -n "$suspect_location" ]; then
      gdb "$EXE" -ex "break $suspect_location" -ex "run < $INPUT"
    else
      gdb "$EXE" -ex "run < $INPUT"
    fi
  else
    echo -e "${YELLOW}Session non interactive (pas de TTY), skip ouverture GDB interactive.${NC}"
  fi
else
  echo -e "${GREEN}Pas de segfault d√©tect√© par GDB.${NC}"
fi

# Analyse Valgrind simple
memory_errors=false
memory_leaks=false
if [ -f "$VG_LOG" ]; then
  if grep -qE "Invalid read|Invalid write|Conditional jump" "$VG_LOG"; then
    memory_errors=true
  fi
  if grep -qE "definitely lost.*[1-9]" "$VG_LOG"; then
    memory_leaks=true
  fi
fi

# R√©sum√© JSON enrichi
echo -e "\n${BLUE}=== 4. G√©n√©ration du r√©sum√© JSON ===${NC}"
timestamp=$(date --iso-8601=seconds)
# √âchapper suspect_location pour JSON (simple)
escaped_suspect_location=$(printf '%s' "$suspect_location" | sed 's/"/\\"/g')

# Construire JSON de mani√®re robuste
if command -v jq >/dev/null 2>&1; then
  jq -n \
    --arg ts "$timestamp" \
    --arg sl "$suspect_location" \
    --argjson segfault "$segfault_detected" \
    --argjson memerr "$memory_errors" \
    --argjson memleak "$memory_leaks" \
    '{
      timestamp: $ts,
      suspect_location: $sl,
      gdb: { segfault_detected: $segfault },
      valgrind: { memory_errors: $memerr, memory_leaks: $memleak }
    }' > "$SUMMARY_JSON" || {
      echo -e "${YELLOW}√âchec jq, fallback manuel${NC}"
      cat > "$SUMMARY_JSON" <<EOF
{
  "timestamp": "$timestamp",
  "suspect_location": "$escaped_suspect_location",
  "gdb": { "segfault_detected": $segfault_detected },
  "valgrind": { "memory_errors": $memory_errors, "memory_leaks": $memory_leaks }
}
EOF
    }
else
  cat > "$SUMMARY_JSON" <<EOF
{
  "timestamp": "$timestamp",
  "suspect_location": "$escaped_suspect_location",
  "gdb": { "segfault_detected": $segfault_detected },
  "valgrind": { "memory_errors": $memory_errors, "memory_leaks": $memory_leaks }
}
EOF
fi
echo -e "${GREEN}R√©sum√© JSON √©crit dans $SUMMARY_JSON${NC}"

# G√©n√©ration du rapport HTML
echo -e "\n${BLUE}=== 5. G√©n√©ration du rapport HTML ===${NC}"
# Lecture des valeurs (sans d√©pendre trop de jq)
if command -v jq >/dev/null 2>&1; then
  segfault_flag=$(jq '.gdb.segfault_detected' "$SUMMARY_JSON")
  mem_err_flag=$(jq '.valgrind.memory_errors' "$SUMMARY_JSON")
  mem_leak_flag=$(jq '.valgrind.memory_leaks' "$SUMMARY_JSON")
  suspect_loc_display=$(jq -r '.suspect_location' "$SUMMARY_JSON")
else
  segfault_flag=$(grep -Po '"segfault_detected":\s*\K(true|false)' "$SUMMARY_JSON" | head -1 || echo false)
  mem_err_flag=$(grep -Po '"memory_errors":\s*\K(true|false)' "$SUMMARY_JSON" | head -1 || echo false)
  mem_leak_flag=$(grep -Po '"memory_leaks":\s*\K(true|false)' "$SUMMARY_JSON" | head -1 || echo false)
  suspect_loc_display=$(grep -Po '"suspect_location":\s*"\K[^"]+' "$SUMMARY_JSON" | head -1 || echo "")
fi

# Helper pour √©chapper HTML
escape_html() {
  printf '%s' "$1" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g;'
}

cat > "$REPORT_HTML" <<EOF
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Rapport debug combin√©</title>
  <style>
    body { font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif; padding:1rem; background:#f5f7fa; }
    h1 { margin-top:0; }
    .box { background:white; border-radius:8px; padding:1rem; margin-bottom:1rem; box-shadow:0 8px 24px rgba(0,0,0,0.08); }
    .status { font-weight:bold; }
    .ok { color: green; }
    .warn { color: orange; }
    .fail { color: red; }
    pre { background:#1e1e28; color:#f0f6fc; padding:0.5rem; overflow:auto; border-radius:4px; }
    code { background:#eef; padding:2px 4px; border-radius:3px; }
  </style>
</head>
<body>
  <h1>Rapport de d√©bogage combin√©</h1>
  <p>G√©n√©r√© le <strong>$timestamp</strong></p>

  <div class="box">
    <h2>R√©sum√©</h2>
    <ul>
      <li>Suspect location: <code>$(escape_html "$suspect_loc_display")</code></li>
      <li>Segfault d√©tect√© (GDB): <span class="$( [ "$segfault_flag" = "true" ] && echo "fail" || echo "ok" )">$segfault_flag</span></li>
      <li>Erreurs m√©moire (Valgrind): <span class="$( [ "$mem_err_flag" = "true" ] && echo "fail" || echo "ok" )">$mem_err_flag</span></li>
      <li>Fuites m√©moire (Valgrind): <span class="$( [ "$mem_leak_flag" = "true" ] && echo "warn" || echo "ok" )">$mem_leak_flag</span></li>
    </ul>
  </div>

  <div class="box">
    <h2>Valgrind (extrait)</h2>
    <pre>$(if [ -f "$VG_LOG" ]; then awk '/Invalid read|Invalid write|Conditional jump/{flag=1} flag{print} /^$/{if(flag){exit}}' "$VG_LOG" | head -n 60 | sed 's/&/\&amp;/g; s/</\&lt;/g;'; else echo "Pas de log Valgrind"; fi)</pre>
  </div>

  <div class="box">
    <h2>GDB (extrait)</h2>
    <pre>$(if [ -f "$GDB_LOG" ]; then grep -E "Program received signal|#0|#1|#2|#3" "$GDB_LOG" | head -n 60 | sed 's/&/\&amp;/g; s/</\&lt;/g;'; else echo "Pas de log GDB"; fi)</pre>
  </div>

  <div class="box">
    <h2>Logs bruts</h2>
    <p>Valgrind: <code>$VG_LOG</code></p>
    <p>GDB: <code>$GDB_LOG</code></p>
    <p>R√©sum√© machine: <code>$SUMMARY_JSON</code></p>
  </div>
</body>
</html>
EOF

echo -e "${GREEN}Rapport HTML √©crit dans $REPORT_HTML${NC}"

# Affichage final synth√©tique
echo -e "\n${BLUE}=== Synth√®se rapide ===${NC}"
echo "Suspect location: ${suspect_location:-(aucune)}"
echo "Segfault d√©tect√©: $segfault_detected"
echo "Erreurs m√©moire Valgrind: $memory_errors"
echo "Fuites m√©moire Valgrind: $memory_leaks"
echo ""
echo "Fichiers g√©n√©r√©s :"
echo "  - $SUMMARY_JSON"
echo "  - $REPORT_HTML"
echo "  - $VG_LOG"
echo "  - $GDB_LOG"
echo ""
echo -e "${GREEN}‚úÖ Analyse termin√©e.${NC}"
echo "Ouvre le rapport : xdg-open $REPORT_HTML"
