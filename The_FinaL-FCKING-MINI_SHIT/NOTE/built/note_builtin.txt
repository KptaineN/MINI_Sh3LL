BUILTIN
Ce code implémente un **système de gestion des commandes built-in** pour votre minishell, fournissant à la fois la détection et l'exécution des commandes intégrées au shell lui-même, par opposition aux programmes externes du système.

La fonction `is_builtin()` constitue un **détecteur de commandes built-in** qui vérifie si une chaîne de commande correspond à l'une des sept commandes intégrées supportées par votre shell. Elle utilise une série de comparaisons avec `ft_strcmp()` combinées par l'opérateur logique `||` pour identifier les commandes `cd`, `echo`, `pwd`, `export`, `unset`, `env`, et `exit`. Cette approche directe et explicite garantit une reconnaissance rapide des commandes built-in, permettant au shell de déterminer immédiatement s'il doit traiter la commande en interne ou lancer un processus externe.

Les fonctions `ft_env()` et `ft_exit()` servent de **wrappers ou d'adaptateurs** qui encapsulent les appels aux véritables implémentations `builtin_env()` et `builtin_exit()`. Cette indirection peut sembler redondante à première vue, mais elle offre plusieurs avantages architecturaux : elle permet d'avoir une interface uniforme pour tous les built-ins, facilite les modifications futures des signatures de fonctions, et peut servir de point d'injection pour du code de logging, de validation, ou de gestion d'erreurs spécifique à certaines commandes.

La fonction `get_builtin_handler()` implémente un **système de récupération de gestionnaire** qui extrait un pointeur de fonction depuis une structure de données de type tableau associatif. Elle accepte un tableau `t_arr *bcmd` contenant des entrées de dictionnaire et un index `idx` pour localiser l'élément désiré. La validation défensive avec `if (!bcmd || idx < 0 || idx >= bcmd->len)` protège contre les accès invalides en vérifiant la nullité du tableau et les bornes de l'index.

Le **mécanisme de récupération** cast l'élément du tableau vers un pointeur `t_dic` (structure de dictionnaire), puis retourne le champ `value` qui contient le pointeur de fonction associé. Cette architecture suggère un système sophistiqué où les commandes built-in sont stockées dans une table de correspondance, permettant une recherche et une exécution dynamiques des gestionnaires de commandes. Cette approche facilite l'ajout de nouvelles commandes built-in et offre une flexibilité supérieure à un simple switch-case, tout en maintenant des performances acceptables pour le nombre limité de commandes built-in typiques d'un shell.

GET_BUILTIN_HANDLER
Cette fonction `get_builtin_handler()` implémente un **système de récupération de pointeur de fonction** qui extrait un gestionnaire de commande built-in depuis une structure de données de type tableau associatif, constituant un composant clé du système de dispatch dynamique de votre minishell.

La **signature complexe** de la fonction `int (*get_builtin_handler(...))(t_shell *shell, char **argv)` mérite une explication détaillée : elle retourne un pointeur vers une fonction qui prend en paramètres un pointeur `t_shell *` et un tableau de chaînes `char **argv`, et qui retourne un `int`. Cette signature correspond exactement à l'interface standardisée de toutes les commandes built-in de votre shell, permettant un traitement uniforme indépendamment de la commande spécifique.

La fonction effectue une **validation défensive rigoureuse** avec `if (!bcmd || idx < 0 || idx >= bcmd->len)` qui vérifie trois conditions critiques : la nullité du tableau de commandes built-in, la validité inférieure de l'index (protection contre les valeurs négatives), et la validité supérieure de l'index (protection contre les dépassements de tableau). Cette triple vérification garantit un accès sécurisé aux données et évite les segfaults potentiels lors de l'accès aux éléments du tableau.

L'**extraction du gestionnaire** s'effectue via un cast explicite `(t_dic *)bcmd->arr[idx]` qui convertit l'élément générique du tableau vers un pointeur de structure de dictionnaire. Cette structure `t_dic` encapsule probablement une paire clé-valeur où la clé est le nom de la commande et la valeur est le pointeur de fonction correspondant. Le retour `dic->value` extrait directement le pointeur de fonction stocké dans cette structure.

Cette architecture suggère un **système de table de dispatch** sophistiqué où les commandes built-in sont organisées dans une structure de données recherchable, permettant une résolution dynamique des gestionnaires de commandes. Cette approche offre une flexibilité supérieure à un simple switch-case car elle permet d'ajouter, modifier ou supprimer des commandes built-in de manière modulaire, tout en maintenant des performances acceptables grâce à l'accès direct par index dans le tableau associatif.

FT_EXIT
Cette fonction `ft_exit()` implémente un **wrapper ou adaptateur** pour la commande built-in `exit` de votre minishell, servant d'interface intermédiaire entre le système de dispatch des commandes et l'implémentation réelle de la fonction `exit`.

La fonction adopte une **signature standardisée** `(t_shell *shell, char **argv)` qui correspond à l'interface commune de toutes les commandes built-in de votre shell. Cette uniformité permet au système de dispatch de traiter toutes les commandes de manière cohérente, indépendamment de leur implémentation spécifique. Le paramètre `shell` fournit l'accès à l'état global du shell (environnement, historique, statuts), tandis que `argv` contient les arguments de la commande sous forme de tableau de chaînes.

L'**implémentation minimale** se contente de déléguer immédiatement l'appel à `builtin_exit(shell, argv)` et de retourner directement sa valeur de retour. Cette indirection peut sembler redondante, mais elle offre plusieurs avantages architecturaux : elle permet d'avoir une couche d'abstraction pour des modifications futures, facilite l'ajout de code de logging ou de validation spécifique, et maintient une séparation claire entre l'interface publique des built-ins et leur implémentation interne.

Cette approche de **délégation transparente** est courante dans les architectures logicielles où l'on souhaite maintenir une interface stable tout en conservant la flexibilité d'évolution de l'implémentation sous-jacente. Dans le contexte de votre minishell, cette fonction s'intègre probablement dans un système de table de dispatch où chaque commande built-in est associée à un pointeur de fonction, permettant une résolution et une exécution dynamiques des commandes selon leur nom.

FT_ENV
Cette fonction `ft_env()` implémente un **wrapper ou adaptateur** pour la commande built-in `env` de votre minishell, servant d'interface standardisée entre le système de dispatch des commandes et l'implémentation effective de la fonction d'affichage de l'environnement.

La fonction respecte une **signature uniforme** `(t_shell *shell, char **argv)` qui constitue l'interface commune à toutes les commandes built-in de votre shell. Cette standardisation permet au système de gestion des commandes de traiter tous les built-ins de manière cohérente, sans distinction particulière selon le type de commande. Le paramètre `shell` donne accès à l'état complet du shell (variables d'environnement, historique, statuts d'exécution), tandis que `argv` contient les arguments de la commande sous forme de tableau de chaînes de caractères.

L'**implémentation par délégation** se contente de transférer immédiatement l'appel vers `builtin_env(shell, argv)` et de propager sa valeur de retour sans modification. Cette indirection apparemment simple cache en réalité une architecture flexible qui sépare l'interface publique des built-ins de leur implémentation concrète. Cette approche facilite la maintenance du code en permettant des modifications de l'implémentation interne sans affecter le système de dispatch des commandes.

Cette technique de **façade fonctionnelle** s'intègre typiquement dans un système de table de correspondance où chaque nom de commande built-in est associé à un pointeur de fonction. Le système peut ainsi résoudre dynamiquement le gestionnaire approprié selon le nom de la commande saisie par l'utilisateur, permettant une exécution transparente des commandes intégrées au shell tout en maintenant une architecture modulaire et extensible pour l'ajout de nouvelles fonctionnalités.

FT_ECHO
Cette fonction `ft_echo()` implémente un **wrapper ou adaptateur** pour la commande built-in `echo` de votre minishell, servant d'interface standardisée entre le système de dispatch des commandes et l'implémentation concrète de la fonction d'affichage de texte.

La fonction adopte une **signature uniforme** `(t_shell *shell, char **argv)` qui constitue l'interface commune partagée par toutes les commandes built-in de votre shell. Cette standardisation architecturale permet au système de gestion des commandes de traiter tous les built-ins de manière homogène, sans nécessiter de logique spécifique selon le type de commande. Le paramètre `shell` fournit l'accès à l'état global du shell (environnement, variables, statuts d'exécution), tandis que `argv` contient les arguments de la commande sous forme de tableau de chaînes de caractères.

L'**implémentation par délégation pure** transfère immédiatement l'appel vers `builtin_echo(shell, argv)` et propage directement sa valeur de retour sans aucune transformation. Cette indirection apparemment redondante constitue en réalité une couche d'abstraction précieuse qui sépare l'interface publique des built-ins de leur implémentation interne. Cette approche facilite la maintenance et l'évolution du code en permettant des modifications de l'implémentation sous-jacente sans affecter le système de dispatch des commandes.

Cette technique de **façade fonctionnelle** s'intègre typiquement dans un système de table de correspondance ou de dispatch où chaque nom de commande built-in est associé à un pointeur de fonction respectant cette signature standardisée. Le système peut ainsi résoudre dynamiquement le gestionnaire approprié selon le nom de la commande saisie par l'utilisateur, permettant une exécution transparente et modulaire des commandes intégrées au shell tout en conservant une architecture extensible pour l'ajout de nouvelles fonctionnalités.

FT_CD
Cette fonction `ft_cd()` implémente un **wrapper ou adaptateur** pour la commande built-in `cd` (change directory) de votre minishell, servant d'interface standardisée entre le système de dispatch des commandes et l'implémentation effective de la fonction de navigation dans les répertoires.

La fonction respecte une **signature uniforme** `(t_shell *shell, char **argv)` qui constitue l'interface commune à toutes les commandes built-in de votre shell. Cette standardisation architecturale permet au système de gestion des commandes de traiter tous les built-ins de manière cohérente et uniforme, sans distinction selon le type de commande spécifique. Le paramètre `shell` donne accès à l'état complet du shell (variables d'environnement, répertoire courant, historique, statuts d'exécution), tandis que `argv` contient les arguments de la commande sous forme de tableau de chaînes de caractères.

L'**implémentation par délégation transparente** se contente de transférer immédiatement l'appel vers `builtin_cd(shell, argv)` et de propager sa valeur de retour sans modification. Cette indirection apparemment simple cache une architecture flexible qui sépare l'interface publique des built-ins de leur implémentation concrète. Cette approche facilite la maintenance du code en permettant des modifications de l'implémentation interne de `cd` sans affecter le système de dispatch des commandes ou d'autres parties du shell.

Cette technique de **façade fonctionnelle** s'intègre dans un système de table de correspondance où chaque nom de commande built-in est associé à un pointeur de fonction respectant cette signature standardisée. Le système peut ainsi résoudre dynamiquement le gestionnaire approprié selon le nom de la commande saisie par l'utilisateur, permettant une exécution transparente des commandes intégrées au shell tout en maintenant une architecture modulaire et extensible pour l'ajout de nouvelles fonctionnalités de navigation ou de gestion de répertoires.

FT_PWD
Cette fonction `ft_pwd()` implémente un **wrapper ou adaptateur** pour la commande built-in `pwd` (print working directory) de votre minishell, servant d'interface standardisée entre le système de dispatch des commandes et l'implémentation concrète de la fonction d'affichage du répertoire de travail courant.

La fonction adopte une **signature uniforme** `(t_shell *shell, char **argv)` qui constitue l'interface commune partagée par toutes les commandes built-in de votre shell. Cette standardisation architecturale permet au système de gestion des commandes de traiter tous les built-ins de manière homogène, sans nécessiter de logique spécifique selon le type de commande. Le paramètre `shell` fournit l'accès à l'état global du shell (environnement, variables, répertoire courant, statuts d'exécution), tandis que `argv` contient les arguments de la commande sous forme de tableau de chaînes de caractères.

L'**implémentation par délégation pure** transfère immédiatement l'appel vers `builtin_pwd(shell, argv)` et propage directement sa valeur de retour sans aucune transformation. Cette indirection apparemment redondante constitue en réalité une couche d'abstraction précieuse qui sépare l'interface publique des built-ins de leur implémentation interne. Cette approche facilite la maintenance et l'évolution du code en permettant des modifications de l'implémentation sous-jacente de `pwd` sans affecter le système de dispatch des commandes.

Cette technique de **façade fonctionnelle** s'intègre typiquement dans un système de table de correspondance ou de dispatch où chaque nom de commande built-in est associé à un pointeur de fonction respectant cette signature standardisée. Le système peut ainsi résoudre dynamiquement le gestionnaire approprié selon le nom de la commande saisie par l'utilisateur, permettant une exécution transparente et modulaire des commandes intégrées au shell tout en conservant une architecture extensible pour l'ajout de nouvelles fonctionnalités de navigation dans le système de fichiers.

FT_EXPORT
Cette fonction `ft_export()` implémente un **wrapper ou adaptateur** pour la commande built-in `export` de votre minishell, servant d'interface standardisée entre le système de dispatch des commandes et l'implémentation effective de la fonction de gestion des variables d'environnement exportées.

La fonction respecte une **signature uniforme** `(t_shell *shell, char **argv)` qui constitue l'interface commune à toutes les commandes built-in de votre shell. Cette standardisation architecturale permet au système de gestion des commandes de traiter tous les built-ins de manière cohérente et uniforme, sans distinction selon le type de commande spécifique. Le paramètre `shell` donne accès à l'état complet du shell (variables d'environnement, variables locales, historique, statuts d'exécution), tandis que `argv` contient les arguments de la commande sous forme de tableau de chaînes de caractères.

L'**implémentation par délégation transparente** se contente de transférer immédiatement l'appel vers `builtin_export(shell, argv)` et de propager sa valeur de retour sans modification. Cette indirection apparemment simple cache une architecture flexible qui sépare l'interface publique des built-ins de leur implémentation concrète. Cette approche facilite la maintenance du code en permettant des modifications de l'implémentation interne d'`export` sans affecter le système de dispatch des commandes ou d'autres parties du shell.

Cette technique de **façade fonctionnelle** s'intègre dans un système de table de correspondance où chaque nom de commande built-in est associé à un pointeur de fonction respectant cette signature standardisée. Le système peut ainsi résoudre dynamiquement le gestionnaire approprié selon le nom de la commande saisie par l'utilisateur, permettant une exécution transparente des commandes intégrées au shell tout en maintenant une architecture modulaire et extensible. Cette approche est particulièrement importante pour `export` car cette commande doit modifier l'environnement du shell parent, nécessitant un accès direct aux structures internes du shell.

FT_UNSET
Cette fonction `ft_unset()` implémente un **wrapper ou adaptateur** pour la commande built-in `unset` de votre minishell, servant d'interface standardisée entre le système de dispatch des commandes et l'implémentation effective de la fonction de suppression des variables d'environnement.

La fonction adopte une **signature uniforme** `(t_shell *shell, char **argv)` qui constitue l'interface commune partagée par toutes les commandes built-in de votre shell. Cette standardisation architecturale permet au système de gestion des commandes de traiter tous les built-ins de manière homogène, sans nécessiter de logique spécifique selon le type de commande. Le paramètre `shell` fournit l'accès à l'état global du shell (environnement, variables locales, historique, statuts d'exécution), tandis que `argv` contient les arguments de la commande sous forme de tableau de chaînes de caractères.

L'**implémentation par délégation pure** transfère immédiatement l'appel vers `builtin_unset(shell, argv)` et propage directement sa valeur de retour sans aucune transformation. Cette indirection apparemment redondante constitue en réalité une couche d'abstraction précieuse qui sépare l'interface publique des built-ins de leur implémentation interne. Cette approche facilite la maintenance et l'évolution du code en permettant des modifications de l'implémentation sous-jacente d'`unset` sans affecter le système de dispatch des commandes.

Cette technique de **façade fonctionnelle** s'intègre typiquement dans un système de table de correspondance ou de dispatch où chaque nom de commande built-in est associé à un pointeur de fonction respectant cette signature standardisée. Le système peut ainsi résoudre dynamiquement le gestionnaire approprié selon le nom de la commande saisie par l'utilisateur, permettant une exécution transparente et modulaire des commandes intégrées au shell. Cette approche est particulièrement cruciale pour `unset` car cette commande doit modifier directement l'environnement du shell parent, nécessitant un accès privilégié aux structures internes de gestion des variables d'environnement.

IS_BUILTIN
Cette fonction `is_builtin()` implémente un **détecteur de commandes built-in** qui détermine si une chaîne de commande correspond à l'une des commandes intégrées supportées par votre minishell, constituant un élément fondamental du système de classification des commandes.

La fonction utilise une **approche de comparaison en chaîne** avec l'opérateur logique `||` pour vérifier si la commande d'entrée correspond exactement à l'une des sept commandes built-in reconnues : `cd`, `echo`, `pwd`, `export`, `unset`, `env`, et `exit`. Chaque comparaison utilise `ft_strcmp()` qui retourne 0 lorsque les chaînes sont identiques, permettant à l'expression `== 0` de produire une valeur booléenne vraie en cas de correspondance.

Cette **liste exhaustive de built-ins** couvre les fonctionnalités essentielles d'un shell Unix moderne : navigation dans le système de fichiers (`cd`, `pwd`), gestion de l'environnement (`export`, `unset`, `env`), affichage de texte (`echo`), et contrôle du shell (`exit`). Ces commandes sont intégrées directement au shell plutôt que d'être des programmes externes, car elles nécessitent un accès direct à l'état interne du shell ou doivent modifier le processus shell lui-même.

Le **retour booléen** de la fonction permet au système de dispatch des commandes de prendre des décisions rapides sur le traitement à appliquer : si `is_builtin()` retourne vrai, la commande sera traitée par le système de built-ins interne ; sinon, le shell tentera de localiser et d'exécuter un programme externe correspondant. Cette classification précoce optimise les performances en évitant des recherches inutiles dans le système de fichiers pour les commandes intégrées, tout en fournissant une interface claire pour distinguer les deux types de commandes dans l'architecture du shell.
