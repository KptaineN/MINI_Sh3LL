##!/bin/bash
# debug_trace_with_prompt_tester.sh
# Usage: ./debug_trace_with_prompt_tester.sh <exécutable> <fichier_d'entrée> [args...]
#
# Comme debug_trace_all.sh, mais :
#  - demande avant de cloner minishell_tester si absent
#  - demande avant de lancer le testeur même s'il est présent

set -u

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

prompt_yes_no() {
    local prompt="$1"
    local default="$2"  # "Y" ou "N"
    local reply
    if [ "$default" = "Y" ]; then
        read -r -p "$prompt [Y/n] " reply
        reply=${reply:-Y}
    else
        read -r -p "$prompt [y/N] " reply
        reply=${reply:-N}
    fi
    if [[ "$reply" =~ ^[Yy]$ ]]; then
        return 0
    else
        return 1
    fi
}

# Arguments
if [ $# -lt 2 ]; then
    echo -e "${RED}Usage: $0 <exécutable> <fichier_d'entrée> [args...]${NC}"
    exit 1
fi
EXE="$1"
INPUT="$2"
shift 2
EXTRA_ARGS=("$@")

# Préparation
if [ ! -x "$EXE" ]; then
    echo -e "${RED}Erreur: '$EXE' n'est pas exécutable ou n'existe pas.${NC}"
    exit 1
fi
if [ ! -f "$INPUT" ]; then
    echo -e "${YELLOW}⚠️  Fichier d'entrée '$INPUT' introuvable.${NC}"
    prompt_yes_no "Créer un test minimal automatiquement ?" "Y" && cat > "$INPUT" <<EOF
pwd
echo autogenerated test
exit
EOF
    [ -f "$INPUT" ] || { echo -e "${RED}Abandon.${NC}"; exit 1; }
fi

# Fichiers / dossiers
mkdir -p .debug_combined
VG_LOG=".debug_combined/valgrind.log"
GDB_LOG=".debug_combined/gdb_combined.log"
GDB_SCRIPT=".debug_combined/gdb_script.gdb"
SUMMARY_JSON="summary.json"
REPORT_HTML="report.html"
TESTER_DIR="minishell_tester"
TESTER_LOG="$TESTER_DIR/tester_output.log"

# Vérif debug symbols
if command -v readelf >/dev/null 2>&1 && readelf --sections "$EXE" | grep -q "\.debug_info"; then
    echo -e "${GREEN}✅ Debug symbols détectés dans '$EXE'.${NC}"
else
    echo -e "${YELLOW}⚠️  Pas (ou peu) de symboles de debug. Recompile avec '-g -O0'.${NC}"
fi

echo -e "\n${BLUE}=== 1. Lancement de Valgrind ===${NC}"
memory_errors=false
memory_leaks=false
suspect_location=""
if command -v valgrind >/dev/null 2>&1; then
    valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all \
             --track-origins=yes --verbose --log-file="$VG_LOG" \
             timeout 15s "$EXE" < "$INPUT" "${EXTRA_ARGS[@]}" >/dev/null 2>&1 || true

    if grep -qE "Invalid read|Invalid write|Conditional jump" "$VG_LOG"; then
        memory_errors=true
    fi
    if grep -qE "definitely lost.*[1-9]" "$VG_LOG"; then
        memory_leaks=true
    fi

    if grep -qE "Invalid read|Invalid write|Conditional jump" "$VG_LOG"; then
        suspect_location=$(awk '
            /Invalid read|Invalid write|Conditional jump/ {flag=1}
            flag && /at [^:]+:[0-9]+/ {
              match($0, /at ([^:]+:[0-9]+)/, a)
              if (a[1]) { print a[1]; exit }
            }
        ' "$VG_LOG")
        if [ -n "$suspect_location" ]; then
            echo -e "${GREEN}Localisation suspecte extraite : ${suspect_location}${NC}"
        else
            func=$(awk '
              /Invalid read|Invalid write|Conditional jump/ {flag=1}
              flag {
                if (match($0, /[a-zA-Z_][a-zA-Z0-9_]*\(/)) {
                  print substr($0, RSTART, RLENGTH)
                  exit
                }
              }
            ' "$VG_LOG" | sed 's/[(]$//')
            if [ -n "$func" ]; then
                suspect_location="$func"
                echo -e "${GREEN}Fonction suspecte extraite : ${suspect_location}${NC}"
            else
                echo -e "${YELLOW}Aucune localisation précise trouvée dans Valgrind.${NC}"
            fi
        fi
    else
        echo -e "${YELLOW}Pas d'erreur mémoire critique détectée par Valgrind.${NC}"
    fi
else
    echo -e "${YELLOW}valgrind non trouvé, analyse mémoire sautée.${NC}"
    echo "" > "$VG_LOG"
fi

echo -e "\n${BLUE}=== 2. GDB ciblé ===${NC}"
# Générer script GDB
cat > "$GDB_SCRIPT" <<EOF
set pagination off
set logging file $GDB_LOG
set logging enabled on
EOF

if [ -n "$suspect_location" ]; then
    echo "break $suspect_location" >> "$GDB_SCRIPT"
else
    echo "break main" >> "$GDB_SCRIPT"
fi

cat >> "$GDB_SCRIPT" <<EOF
run < $INPUT
echo "\\n=== Backtrace complète ===\\n"
backtrace full
echo "\\n=== Variables locales ===\\n"
info locals
echo "\\n=== Registres ===\\n"
info registers
echo "\\n=== Disassembly autour du PC ===\\n"
x/10i \$pc
quit
EOF

if command -v gdb >/dev/null 2>&1; then
    gdb -batch -x "$GDB_SCRIPT" "$EXE" >/dev/null 2>&1 || true
else
    echo -e "${YELLOW}gdb non trouvé, analyse de crash impossible.${NC}"
    echo "" > "$GDB_LOG"
fi

segfault_detected=false
if grep -qE "Program received signal SIGSEGV|Segmentation fault" "$GDB_LOG" 2>/dev/null; then
    segfault_detected=true
    echo -e "${RED}🚨 Segfault détecté dans GDB.${NC}"
    if [ -t 1 ]; then
        echo -e "${BLUE}Ouverture interactive de GDB pour investigation...${NC}"
        if [ -n "$suspect_location" ]; then
            gdb "$EXE" -ex "break $suspect_location" -ex "run < $INPUT"
        else
            gdb "$EXE" -ex "run < $INPUT"
        fi
    fi
else
    echo -e "${GREEN}Pas de segfault détecté par GDB.${NC}"
fi

echo -e "\n${BLUE}=== 3. minishell_tester ===${NC}"
tester_summary="N/A"
tester_status="skipped"

# Cloner si absent
if [ ! -d "$TESTER_DIR" ]; then
    if command -v git >/dev/null 2>&1; then
        if prompt_yes_no "Le dépôt minishell_tester est absent. Le cloner ?" "Y"; then
            echo -e "${BLUE}Clonage de minishell_tester...${NC}"
            if git clone --depth 1 https://github.com/LucasKuhn/minishell_tester.git "$TESTER_DIR" >/dev/null 2>&1; then
                echo -e "${GREEN}Clonage réussi.${NC}"
            else
                echo -e "${YELLOW}Échec du clonage.${NC}"
                tester_status="unavailable"
            fi
        else
            echo -e "${YELLOW}Pas de clonage demandé.${NC}"
            tester_status="skipped"
        fi
    else
        echo -e "${YELLOW}git non disponible, impossible de cloner.${NC}"
        tester_status="unavailable"
    fi
fi

# Demande pour lancer
run_tester=true
if ! prompt_yes_no "Lancer minishell_tester ?" "Y"; then
    run_tester=false
    echo -e "${YELLOW}Exécution du testeur ignorée par l'utilisateur.${NC}"
fi

if [ "$run_tester" = true ] && [ -d "$TESTER_DIR" ] && [ "$tester_status" != "unavailable" ]; then
    pushd "$TESTER_DIR" >/dev/null || true
    echo -e "${BLUE}Exécution de minishell_tester...${NC}"
    ./tester 2>&1 | tee tester_output.log
    popd >/dev/null || true

    summary_line=$(grep -E '[0-9]+/[0-9]+' "$TESTER_LOG" | tail -n1 | tr -d '\r')
    if [ -n "$summary_line" ]; then
        tester_summary="$summary_line"
        passed=$(echo "$summary_line" | awk -F'/' '{print $1}')
        total=$(echo "$summary_line" | awk -F'/' '{print $2}')
        if [ "$passed" = "$total" ]; then
            tester_status="success"
        else
            tester_status="fail"
        fi
    else
        tester_status="error"
    fi
fi

echo -e "${BLUE}minishell_tester: résumé=${tester_summary}, statut=${tester_status}${NC}"

echo -e "\n${BLUE}=== 4. Génération du résumé JSON ===${NC}"
timestamp=$(date --iso-8601=seconds)
escaped_suspect_location=$(printf '%s' "$suspect_location" | sed 's/"/\\"/g')

if command -v jq >/dev/null 2>&1; then
    jq -n \
      --arg ts "$timestamp" \
      --arg sl "$suspect_location" \
      --argjson segfault "$segfault_detected" \
      --argjson memerr "$memory_errors" \
      --argjson memleak "$memory_leaks" \
      --arg tester_summary "$tester_summary" \
      --arg tester_status "$tester_status" \
      '{
        timestamp: $ts,
        suspect_location: $sl,
        gdb: { segfault_detected: $segfault },
        valgrind: { memory_errors: $memerr, memory_leaks: $memleak },
        minishell_tester: { summary: $tester_summary, status: $tester_status }
      }' > "$SUMMARY_JSON" || {
        echo -e "${YELLOW}Échec jq, fallback manuel${NC}"
        cat > "$SUMMARY_JSON" <<EOF
{
  "timestamp": "$timestamp",
  "suspect_location": "$escaped_suspect_location",
  "gdb": { "segfault_detected": $segfault_detected },
  "valgrind": { "memory_errors": $memory_errors, "memory_leaks": $memory_leaks },
  "minishell_tester": { "summary": "$tester_summary", "status": "$tester_status" }
}
EOF
    }
else
    cat > "$SUMMARY_JSON" <<EOF
{
  "timestamp": "$timestamp",
  "suspect_location": "$escaped_suspect_location",
  "gdb": { "segfault_detected": $segfault_detected },
  "valgrind": { "memory_errors": $memory_errors, "memory_leaks": $memory_leaks },
  "minishell_tester": { "summary": "$tester_summary", "status": "$tester_status" }
}
EOF
fi
echo -e "${GREEN}Résumé JSON écrit dans $SUMMARY_JSON${NC}"

echo -e "\n${BLUE}=== 5. Génération du rapport HTML ===${NC}"
# Lire valeurs
if command -v jq >/dev/null 2>&1; then
    segfault_flag=$(jq '.gdb.segfault_detected' "$SUMMARY_JSON")
    mem_err_flag=$(jq '.valgrind.memory_errors' "$SUMMARY_JSON")
    mem_leak_flag=$(jq '.valgrind.memory_leaks' "$SUMMARY_JSON")
    suspect_loc_display=$(jq -r '.suspect_location' "$SUMMARY_JSON")
    tester_stat=$(jq -r '.minishell_tester.status' "$SUMMARY_JSON")
    tester_sum=$(jq -r '.minishell_tester.summary' "$SUMMARY_JSON")
else
    segfault_flag=$(grep -Po '"segfault_detected":\s*\K(true|false)' "$SUMMARY_JSON" | head -1 || echo false)
    mem_err_flag=$(grep -Po '"memory_errors":\s*\K(true|false)' "$SUMMARY_JSON" | head -1 || echo false)
    mem_leak_flag=$(grep -Po '"memory_leaks":\s*\K(true|false)' "$SUMMARY_JSON" | head -1 || echo false)
    suspect_loc_display=$(grep -Po '"suspect_location":\s*"\K[^"]+' "$SUMMARY_JSON" | head -1 || echo "")
    tester_stat=$(grep -Po '"status":\s*"\K[^"]+' "$SUMMARY_JSON" | head -1 || echo "skipped")
    tester_sum=$(grep -Po '"summary":\s*"\K[^"]+' "$SUMMARY_JSON" | head -1 || echo "N/A")
fi

tester_class="ok"
if [ "$tester_stat" = "fail" ]; then
    tester_class="fail"
elif [ "$tester_stat" = "error" ] || [ "$tester_stat" = "unavailable" ]; then
    tester_class="warn"
fi

escape_html() {
    printf '%s' "$1" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g;'
}

cat > "$REPORT_HTML" <<EOF
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Rapport debug complet</title>
  <style>
    body { font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif; padding:1rem; background:#f5f7fa; }
    h1 { margin-top:0; }
    .card { background:white; border-radius:8px; padding:1rem; margin-bottom:1rem; box-shadow:0 8px 24px rgba(0,0,0,0.08); }
    .ok { color: green; font-weight:bold; }
    .warn { color: orange; font-weight:bold; }
    .fail { color: red; font-weight:bold; }
    pre { background:#1e1e28; color:#f0f6fc; padding:0.5rem; overflow:auto; border-radius:4px; }
    code { background:#eef; padding:2px 4px; border-radius:3px; }
  </style>
</head>
<body>
  <h1>Rapport de débogage complet</h1>
  <p>Généré le <strong>$timestamp</strong></p>

  <div class="card">
    <h2>Résumé</h2>
    <ul>
      <li>Localisation suspecte: <code>$(escape_html "$suspect_loc_display")</code></li>
      <li>Segfault (GDB): <span class="$( [ "$segfault_flag" = "true" ] && echo fail || echo ok )">$segfault_flag</span></li>
      <li>Erreurs mémoire (Valgrind): <span class="$( [ "$mem_err_flag" = "true" ] && echo fail || echo ok )">$mem_err_flag</span></li>
      <li>Fuites mémoire (Valgrind): <span class="$( [ "$mem_leak_flag" = "true" ] && echo warn || echo ok )">$mem_leak_flag</span></li>
      <li>Minishell Tester: <span class="$tester_class">$tester_stat</span> ($tester_sum)</li>
    </ul>
  </div>

  <div class="card">
    <h2>Valgrind (extrait)</h2>
    <pre>$(if [ -f "$VG_LOG" ]; then awk '/Invalid read|Invalid write|Conditional jump/{flag=1} flag{print} /^$/{if(flag){exit}}' "$VG_LOG" | head -n 80 | sed 's/&/\&amp;/g; s/</\&lt;/g;'; else echo "Pas de log Valgrind"; fi)</pre>
  </div>

  <div class="card">
    <h2>GDB (extrait)</h2>
    <pre>$(if [ -f "$GDB_LOG" ]; then grep -E "Program received signal|#0|#1|#2|#3" "$GDB_LOG" | head -n 80 | sed 's/&/\&amp;/g; s/</\&lt;/g;'; else echo "Pas de log GDB"; fi)</pre>
  </div>

  <div class="card">
    <h2>Minishell Tester</h2>
    <p>Status: <span class="$tester_class">$tester_stat</span></p>
    <p>Résumé: <code>$(escape_html "$tester_sum")</code></p>
    <pre>$(if [ -f "$TESTER_LOG" ]; then tail -n 120 "$TESTER_LOG" | sed 's/&/\&amp;/g; s/</\&lt;/g;'; else echo "Pas de log du testeur"; fi)</pre>
  </div>

  <div class="card">
    <h2>Logs bruts</h2>
    <p>Valgrind: <code>$VG_LOG</code></p>
    <p>GDB: <code>$GDB_LOG</code></p>
    <p>Résumé machine: <code>$SUMMARY_JSON</code></p>
  </div>
</body>
</html>
EOF

echo -e "${GREEN}Rapport HTML écrit dans $REPORT_HTML${NC}"

echo -e "\n${BLUE}=== Synthèse finale ===${NC}"
echo "Localisation suspecte: ${suspect_location:-(aucune)}"
echo "Segfault détecté: $segfault_detected"
echo "Erreurs mémoire: $memory_errors"
echo "Fuites mémoire: $memory_leaks"
echo "Tester résumé: $tester_summary"
echo "Tester statut: $tester_status"

echo -e "\nFichiers générés :"
echo "  - $SUMMARY_JSON"
echo "  - $REPORT_HTML"
echo "  - $VG_LOG"
echo "  - $GDB_LOG"
echo "  - $TESTER_LOG (si exécuté)"

echo -e "\n${GREEN}✅ Analyse complète terminée.${NC}"
echo "Ouvre le rapport : xdg-open $REPORT_HTML"
