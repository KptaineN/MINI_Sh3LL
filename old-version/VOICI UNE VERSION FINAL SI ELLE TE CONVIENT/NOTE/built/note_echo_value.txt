GET_DOLLAR_VALUE
Cette fonction `get_dollar_value()` impl√©mente le **moteur d'extraction de valeurs** pour les expressions de substitution de variables commen√ßant par `$` dans votre minishell, g√©rant √† la fois les variables sp√©ciales et les variables d'environnement standard avec un parsing intelligent et une gestion m√©moire rigoureuse.

La fonction commence par calculer `k = *pos + 1` pour positionner l'index sur le caract√®re suivant imm√©diatement le symbole `$`, permettant d'analyser le type d'expression √† traiter. Cette approche syst√©matique garantit que la fonction examine toujours le bon contexte pour d√©terminer la nature de la substitution √† effectuer.

Le **traitement de la variable sp√©ciale `$?`** constitue un cas prioritaire g√©r√© par `if (arg[k] == '?')`. Cette expression repr√©sente le code de sortie de la derni√®re commande ex√©cut√©e, une variable fondamentale dans les shells Unix. La fonction utilise `ft_itoa(sh->exit_status)` pour convertir le code num√©rique en cha√Æne allou√©e dynamiquement, met √† jour la position avec `*pos = k + 1` pour pointer apr√®s le `?`, et retourne imm√©diatement la valeur. Cette gestion directe optimise le traitement des variables sp√©ciales fr√©quemment utilis√©es.

Pour les **variables d'environnement standard**, la fonction d√©l√®gue l'extraction du nom √† `extract_key(arg, k, &len)` qui parse le nom de variable selon les r√®gles de syntaxe shell et retourne √† la fois la cl√© extraite et sa longueur via le param√®tre `len`. La v√©rification `if (!key)` g√®re les cas d'erreur de parsing (noms invalides, allocation √©chou√©e) en mettant √† jour la position et retournant NULL, permettant aux fonctions appelantes de g√©rer gracieusement ces situations d'exception.

La **r√©solution et finalisation** utilise `get_env_or_special_value(sh, key)` pour rechercher la valeur correspondante dans l'environnement du shell ou parmi d'autres variables sp√©ciales. La fonction lib√®re imm√©diatement la cl√© temporaire avec `free(key)` pour √©viter les fuites m√©moire, met √† jour la position finale avec `*pos = k + len` pour pointer apr√®s le nom de variable complet, et retourne la valeur trouv√©e. Cette architecture garantit une gestion m√©moire propre tout en maintenant la synchronisation pr√©cise des positions de parsing pour les traitements s√©quentiels de substitution de variables multiples.

GET_ENV_OR_SPECIAL_VALUE
Cette fonction `get_env_or_special_value()` impl√©mente un **syst√®me de r√©solution de variables hi√©rarchique** qui recherche la valeur d'une variable selon un ordre de priorit√© d√©fini : d'abord dans l'environnement du shell, puis parmi les variables sp√©ciales, et enfin retourne une cha√Æne vide si aucune correspondance n'est trouv√©e.

La fonction commence par une **recherche dans l'environnement standard** avec `find_env_value(shell->env, key)` qui parcourt la liste des variables d'environnement du shell pour localiser la cl√© demand√©e. Si cette recherche aboutit (`if (val_env)`), la fonction retourne imm√©diatement une copie allou√©e dynamiquement de la valeur avec `ft_strdup(val_env)`. Cette priorit√© donn√©e aux variables d'environnement suit la s√©mantique des shells Unix o√π les variables utilisateur priment sur les variables syst√®me.

En cas d'**√©chec de la recherche environnementale**, la fonction tente une seconde approche avec `get_special_var(key)` qui v√©rifie si la cl√© correspond √† une variable sp√©ciale du shell (comme des variables internes, des param√®tres positionnels, ou des variables syst√®me pr√©d√©finies). Si une variable sp√©ciale est trouv√©e (`if (sp)`), sa valeur est retourn√©e directement. Cette architecture √† deux niveaux permet de g√©rer de mani√®re transparente les deux types de variables sans exposer cette complexit√© aux fonctions appelantes.

Le **m√©canisme de fallback** avec `return (ft_strdup(""))` garantit que la fonction retourne toujours une cha√Æne valide, m√™me pour des variables inexistantes. Cette approche suit la convention des shells Unix o√π les variables non d√©finies sont substitu√©es par des cha√Ænes vides plut√¥t que de provoquer des erreurs. L'utilisation syst√©matique de `ft_strdup()` assure que toutes les valeurs de retour sont allou√©es dynamiquement de mani√®re coh√©rente, facilitant la gestion m√©moire dans les fonctions appelantes qui peuvent lib√©rer uniform√©ment tous les r√©sultats sans se pr√©occuper de leur origine (environnement, variables sp√©ciales, ou cha√Æne vide par d√©faut).

Cette fonction constitue ainsi un **point d'abstraction central** qui unifie l'acc√®s aux diff√©rents types de variables du shell, offrant une interface simple et coh√©rente pour le syst√®me de substitution de variables tout en g√©rant la complexit√© de la recherche multi-sources et la gestion m√©moire de mani√®re transparente.

EXTRACT_KEY
Cette fonction `extract_key()` impl√©mente un **extracteur de nom de variable** qui parse et extrait une cl√© de variable d'environnement valide depuis une cha√Æne de caract√®res, en respectant les r√®gles de syntaxe des identifiants Unix et en fournissant √† la fois le nom extrait et sa longueur.

La fonction utilise une **boucle de validation caract√®re par caract√®re** avec `while (is_valid_key_char(arg[start + i]))` qui parcourt la cha√Æne √† partir de la position `start` et continue tant que chaque caract√®re respecte les conventions de nommage des variables. La fonction `is_valid_key_char()` v√©rifie que chaque caract√®re est soit alphanum√©rique soit un underscore, suivant les standards POSIX pour les identifiants de variables d'environnement. L'incr√©mentation de `i` compte simultan√©ment le nombre de caract√®res valides rencontr√©s.

La **double sortie de r√©sultats** constitue une caract√©ristique importante de cette fonction : elle stocke la longueur calcul√©e dans `*len = i` pour permettre aux fonctions appelantes de conna√Ætre pr√©cis√©ment la taille du nom de variable extrait, information cruciale pour l'avancement correct des index de parsing. Cette approche √©vite aux fonctions utilisatrices de recalculer la longueur avec `strlen()`, optimisant les performances du syst√®me de parsing.

La **validation de r√©sultat** avec `if (i == 0)` g√®re le cas o√π aucun caract√®re valide n'est trouv√© √† la position de d√©part, indiquant soit une erreur de syntaxe soit une tentative d'extraction sur un caract√®re non-alphab√©tique. Dans ce cas, la fonction retourne `NULL` pour signaler l'√©chec, permettant aux fonctions appelantes de g√©rer gracieusement les erreurs de parsing sans risquer de segfaults.

La **extraction finale** utilise `ft_substr(arg, start, i)` pour cr√©er une nouvelle cha√Æne allou√©e dynamiquement contenant exactement les `i` caract√®res du nom de variable, depuis la position `start`. Cette fonction retourne une copie ind√©pendante du nom de variable qui peut √™tre manipul√©e et lib√©r√©e s√©par√©ment de la cha√Æne source, facilitant la gestion m√©moire dans le syst√®me de substitution de variables o√π les noms extraits sont temporairement stock√©s avant r√©solution de leurs valeurs.

GET_SPECIAL_VAR
Cette fonction `get_special_var()` impl√©mente un **syst√®me de variables sp√©ciales personnalis√©es** qui reconna√Æt et retourne des valeurs pr√©d√©finies pour certaines cl√©s sp√©cifiques, constituant un m√©canisme d'easter eggs ou de variables internes personnalis√©es dans votre minishell.

La fonction utilise une **approche de comparaison s√©quentielle** avec `ft_strncmp()` pour v√©rifier si la cl√© d'entr√©e correspond exactement √† l'une des variables sp√©ciales reconnues. L'utilisation de `ft_strlen("NRICO") + 1` comme longueur de comparaison garantit que la correspondance inclut le caract√®re de fin de cha√Æne `\0`, assurant une √©galit√© stricte et √©vitant les correspondances partielles accidentelles. Cette pr√©cision dans la comparaison est cruciale pour √©viter qu'une variable comme "NRICO_TEST" soit incorrectement reconnue comme "NRICO".

Les **deux variables sp√©ciales d√©finies** - "NRICO" et "NOE" - semblent √™tre des r√©f√©rences personnalis√©es aux d√©veloppeurs du projet, chacune associ√©e √† une description humoristique avec des emojis. La variable "NOE" retourne "le meilleur dev de la galaxie üöÄ" tandis que "NRICO" retourne "le 2 eme meilleur dev de la galaxie üöÄ", sugg√©rant une hi√©rarchie playful entre les contributeurs du projet. Ces cha√Ænes sont dupliqu√©es avec `ft_strdup()` pour maintenir la coh√©rence de gestion m√©moire avec le reste du syst√®me.

Le **m√©canisme de fallback** avec `return (NULL)` indique qu'aucune variable sp√©ciale ne correspond √† la cl√© demand√©e, permettant aux fonctions appelantes de continuer leur recherche dans d'autres sources (comme l'environnement standard). Cette architecture modulaire facilite l'extension du syst√®me : de nouvelles variables sp√©ciales peuvent √™tre ajout√©es simplement en ins√©rant de nouveaux blocs conditionnels avant le retour NULL.

Cette fonction constitue un **exemple d'extensibilit√©** du syst√®me de variables de votre minishell, d√©montrant comment des fonctionnalit√©s personnalis√©es peuvent √™tre int√©gr√©es de mani√®re transparente dans le m√©canisme standard de substitution de variables. Elle illustre √©galement une approche ludique du d√©veloppement o√π les d√©veloppeurs peuvent laisser leur signature dans le code sous forme de variables internes amusantes, ajoutant une touche de personnalit√© au projet technique.

FIND_ENV_VALUE
Cette fonction `find_env_value()` impl√©mente un **algorithme de recherche lin√©aire** dans une liste cha√Æn√©e de variables d'environnement, localisant une variable sp√©cifique par sa cl√© et retournant directement un pointeur vers sa valeur sans allocation m√©moire suppl√©mentaire.

La fonction utilise une **approche de parcours s√©quentiel** classique pour les listes cha√Æn√©es, avec une boucle `while (env)` qui it√®re sur chaque n≈ìud jusqu'√† atteindre la fin de la liste (pointeur NULL). √Ä chaque it√©ration, elle extrait la structure `t_env` encapsul√©e dans le n≈ìud courant via `entry = env->content`, permettant d'acc√©der aux champs `key` et `value` de la variable d'environnement stock√©e.

La **logique de comparaison** utilise `ft_strcmp(entry->key, key) == 0` pour v√©rifier l'√©galit√© exacte entre la cl√© recherch√©e et la cl√© de l'entr√©e courante. Cette comparaison de cha√Ænes garantit une correspondance stricte, √©vitant les fausses correspondances avec des noms de variables similaires. D√®s qu'une correspondance est trouv√©e, la fonction retourne imm√©diatement `entry->value`, optimisant les performances en √©vitant de parcourir inutilement le reste de la liste.

Le **retour direct de pointeur** vers `entry->value` constitue une caract√©ristique importante de cette fonction : elle ne cr√©e pas de copie de la valeur mais retourne un pointeur vers la cha√Æne originale stock√©e dans la structure d'environnement. Cette approche est efficace en termes de m√©moire et de performance car elle √©vite les allocations dynamiques, mais elle implique que la valeur retourn√©e ne doit pas √™tre modifi√©e par le code appelant et reste valide tant que la structure d'environnement existe.

La **gestion d'√©chec** avec `return (NULL)` indique clairement que la variable recherch√©e n'existe pas dans l'environnement. Cette convention de retour permet aux fonctions appelantes de distinguer facilement entre une variable inexistante (NULL) et une variable existante avec une valeur vide (pointeur vers cha√Æne vide), facilitant la logique de gestion des cas d'erreur dans le syst√®me de substitution de variables du shell.
