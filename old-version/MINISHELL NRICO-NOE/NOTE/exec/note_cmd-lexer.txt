COUNT_ARG_CMD
Cette fonction `count_args_cmd()` implémente un **compteur d'arguments de commande** qui détermine le nombre d'arguments associés à une commande spécifique dans la structure de données parsée du shell, servant de fonction utilitaire pour l'allocation mémoire et la gestion des tableaux d'arguments lors de l'exécution des commandes.

La fonction commence par une **validation défensive rigoureuse** avec `if (!sh || !sh->parsed_args || !sh->parsed_args->arr)` qui vérifie trois niveaux de pointeurs pour s'assurer que toute la chaîne de structures de données est valide. Cette vérification en cascade protège contre les segfaults en cas de structures partiellement initialisées ou corrompues, retournant 0 pour indiquer qu'aucun argument n'est disponible dans ces conditions d'erreur.

La **phase d'extraction des données** récupère les informations essentielles depuis la structure `sh->parsed_args` : le tableau d'arguments avec `arr = (char **)sh->parsed_args->arr` et sa longueur avec `len = sh->parsed_args->len`. Le cast explicite vers `(char **)` suggère que la structure utilise un type générique `void *` pour le stockage, nécessitant une conversion de type pour accéder aux chaînes de caractères. Cette approche permet une flexibilité dans la structure de données tout en maintenant la sécurité des types lors de l'accès.

Le **calcul principal** délègue le travail réel à `count_args_core(sh, arr, i, len)` qui implémente probablement la logique complexe de parcours et de comptage en tenant compte des séparateurs de commandes, des pipes, et d'autres éléments syntaxiques du shell. Le paramètre `i` représente probablement l'index de départ ou l'identifiant de la commande dont on veut compter les arguments dans le tableau parsé.

La **logique de normalisation** avec `if (n == 0) return (1)` constitue un détail important : elle garantit qu'une commande a toujours au moins un argument (typiquement son propre nom), même si le comptage de base retourne zéro. Cette convention respecte la sémantique Unix où `argv[0]` contient toujours le nom de la commande, assurant que les fonctions d'exécution ultérieures reçoivent des tableaux d'arguments bien formés avec au minimum l'élément de base requis pour l'identification de la commande.

COUNT_ARGS_CORE
Cette fonction `count_args_core()` implémente un **algorithme de comptage d'arguments** sophistiqué qui parse un tableau de tokens shell pour déterminer le nombre d'arguments effectifs d'une commande, en distinguant intelligemment entre les arguments réels et les opérateurs de shell (pipes, redirections, etc.).

La fonction utilise une **boucle de parsing séquentiel** avec `while (i < len && arr[i])` qui parcourt le tableau depuis l'index de départ `i` jusqu'à rencontrer la fin du tableau ou un pointeur NULL. À chaque itération, elle examine le token courant avec `is_in_t_arr_dic_str(sh->oper, arr[i])` pour déterminer s'il correspond à un opérateur shell connu (comme `|`, `>`, `<`, `>>`, etc.). Cette fonction retourne l'index de l'opérateur dans la table des opérateurs ou -1 si le token n'est pas un opérateur.

La **logique de traitement des opérateurs** se divise en deux cas distincts lorsqu'un opérateur est détecté (`if (op_idx != -1)`). Si l'opérateur est une redirection (vérifié par `is_redir_op_idx(op_idx)`), la fonction utilise `skip_redir_token()` pour avancer l'index au-delà de l'opérateur et de son argument associé (par exemple, pour `> fichier.txt`, elle ignore à la fois `>` et `fichier.txt`). Cette logique respecte la syntaxe shell où les redirections consomment un argument qui ne fait pas partie des arguments de la commande elle-même.

Pour les **opérateurs non-redirection** (comme les pipes `|`), la fonction exécute un `break` qui termine immédiatement le comptage. Cette approche reconnaît que les pipes marquent la fin d'une commande et le début de la suivante dans un pipeline, délimitant ainsi naturellement l'étendue des arguments de la commande courante. Cette logique est fondamentale pour traiter correctement des commandes complexes comme `cat file1 file2 | grep pattern | sort`.

Le **comptage des arguments réels** s'effectue dans la branche `else` où les tokens qui ne sont pas des opérateurs sont considérés comme des arguments légitimes de la commande. Le compteur `n_args` est incrémenté et l'index `i` avance d'une position. Cette approche garantit que seuls les véritables arguments de la commande (fichiers, options, paramètres) sont comptabilisés, excluant les éléments syntaxiques du shell qui ne doivent pas être passés à la commande lors de son exécution via `execve()`.

SKIP_REDIR_TOKEN
Cette fonction `skip_redir_token()` implémente un **mécanisme de saut de tokens de redirection** qui avance l'index de parsing au-delà d'un opérateur de redirection et de son fichier cible associé, permettant au système de comptage d'arguments d'ignorer correctement les éléments syntaxiques qui ne font pas partie des arguments effectifs de la commande.

La fonction commence par **récupérer les métadonnées de l'opérateur** via `d = (t_dic *)sh->oper->arr[op_idx]`, où `op_idx` est l'index de l'opérateur de redirection dans la table des opérateurs du shell. Cette structure `t_dic` contient probablement la clé (le symbole de l'opérateur comme `>`, `>>`, `<`) et d'autres informations associées. L'accès direct par index optimise les performances car l'opérateur a déjà été identifié par les fonctions appelantes.

La **logique de comparaison de longueurs** avec `if ((int)ft_strlen(arr[i]) == (int)ft_strlen(d->key))` constitue le cœur de la fonction. Cette condition vérifie si le token courant dans le tableau correspond exactement en longueur à l'opérateur attendu. Si les longueurs correspondent, cela indique que l'opérateur de redirection est un token séparé (par exemple `>` et `fichier.txt` sont deux tokens distincts), nécessitant un incrément supplémentaire de `i++` pour passer au-delà de l'opérateur lui-même.

Cette logique gère intelligemment deux **formats de redirection possibles** : les redirections avec espaces (`> fichier.txt`) où l'opérateur et le nom de fichier sont des tokens séparés, et les redirections collées (`>fichier.txt`) où ils forment un seul token. Dans le premier cas, la fonction incrémente deux fois `i` (une fois conditionnellement pour l'opérateur, une fois systématiquement pour le fichier), tandis que dans le second cas, un seul incrément suffit car le token entier contient à la fois l'opérateur et le nom de fichier.

L'**incrément final systématique** `i++` garantit que l'index pointe vers le prochain token après la construction de redirection complète, quelle que soit sa forme syntaxique. Cette approche unifie le traitement des différents formats de redirection tout en maintenant la cohérence du parsing séquentiel. Le retour de la nouvelle position d'index permet aux fonctions appelantes de continuer le traitement à partir du bon emplacement, évitant de comptabiliser les éléments de redirection comme des arguments de commande lors du calcul de la taille des tableaux d'arguments.

IS_REDIR_OP_IDX
Cette fonction `is_redir_op_idx()` implémente un **classificateur d'opérateurs de redirection** qui détermine si un index d'opérateur correspond à une redirection de fichier plutôt qu'à d'autres types d'opérateurs shell comme les pipes ou les séparateurs de commandes.

La fonction utilise une **logique de plage inversée** avec `return (op_idx < 2 || op_idx > 4)` qui identifie les opérateurs de redirection en excluant une plage spécifique d'index. Selon le commentaire, les opérateurs aux index 2, 3 et 4 correspondent respectivement au pipe `|` et aux séparateurs de commandes, tandis que les index en dehors de cette plage (0, 1, 5+) représentent les opérateurs de redirection comme `<<`, `>>`, `<`, et `>`.

Cette **approche par exclusion** suggère une organisation spécifique de la table des opérateurs où les différents types d'opérateurs sont regroupés par catégorie fonctionnelle. Les opérateurs de redirection (qui manipulent les flux d'entrée/sortie vers des fichiers) sont probablement placés aux positions 0-1 et 5+ dans le tableau, tandis que les opérateurs de contrôle de flux (pipes et séparateurs qui affectent l'exécution des commandes) occupent les positions centrales 2-4.

Cette classification est **cruciale pour le parsing** car elle permet au système de traitement des commandes de distinguer entre les opérateurs qui nécessitent un traitement spécial des arguments (redirections qui consomment un nom de fichier) et ceux qui marquent des transitions entre commandes (pipes et séparateurs). Cette distinction guide les algorithmes de comptage d'arguments et de construction des tableaux d'exécution, garantissant que les redirections et leurs fichiers cibles ne sont pas comptabilisés comme des arguments de commande lors de la préparation des appels `execve()`.

La fonction constitue ainsi un **élément central du lexer** qui encode la sémantique des différents opérateurs shell dans une logique de classification simple mais efficace, permettant un traitement différencié selon le type d'opérateur rencontré lors du parsing des lignes de commande complexes.

BUILD_CMD_LIST
Cette fonction `build_cmd_list()` implémente un **constructeur de liste de commandes** qui transforme le tableau de tokens parsés en une structure de données organisée sous forme de liste chaînée, facilitant l'exécution séquentielle des commandes dans votre minishell.

La fonction commence par une **validation défensive** avec `if (!shell || !shell->tokens)` qui vérifie la validité des structures de données essentielles avant de procéder au traitement. Cette vérification précoce protège contre les segfaults et garantit que la fonction peut opérer sur des données cohérentes. L'**initialisation de l'état** remet à zéro la liste de commandes avec `shell->cmd_head = NULL`, `shell->cmd_tail = NULL`, et `shell->n_cmd = 0`, préparant une structure propre pour la construction de la nouvelle liste.

La **boucle de traitement principal** parcourt séquentiellement tous les tokens avec `while (i < shell->n_tokens)`, examinant chaque token pour identifier ceux qui représentent des commandes. La récupération du token courant via `tok = &shell->tokens[i]` utilise un pointeur vers l'élément du tableau, optimisant l'accès aux données sans copie inutile. Cette approche permet un traitement efficace même pour des lignes de commande complexes contenant de nombreux tokens.

La **logique de filtrage** avec `if (tok->type == TOKEN_CMD || tok->type == TOKEN_BCMD)` sélectionne spécifiquement les tokens de type commande, qu'il s'agisse de commandes externes (`TOKEN_CMD`) ou de commandes built-in (`TOKEN_BCMD`). Cette distinction permet au système de traiter uniformément les deux types de commandes tout en préservant leur classification pour les phases d'exécution ultérieures. Les autres types de tokens (arguments, opérateurs, redirections) sont ignorés à ce niveau car ils seront traités dans le contexte de leurs commandes associées.

Le **traitement délégué** utilise `process_cmd_token(shell, tok, &prev)` pour gérer la logique complexe d'ajout de chaque commande à la liste chaînée. Le passage de `&prev` par référence permet à cette fonction de maintenir la continuité de la liste en mettant à jour le pointeur vers la commande précédente. La vérification `if (!process_cmd_token(...))` gère les cas d'erreur (allocation mémoire échouée, corruption de données) en terminant prématurément la construction, évitant de créer des structures partiellement formées qui pourraient causer des problèmes lors de l'exécution.
