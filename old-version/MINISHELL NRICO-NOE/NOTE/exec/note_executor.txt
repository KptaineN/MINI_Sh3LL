EXECUTE_CMD
Cette fonction `execute_cmd()` implémente le **moteur d'exécution de commandes externes** de votre minishell, orchestrant le processus complet de résolution, préparation et lancement d'un programme externe via l'appel système `execve()`.

La fonction commence par préparer les arguments avec `prepare_or_run_builtin(shell, cmd, &args)` qui traite le token de commande et génère un tableau d'arguments formaté. Cette fonction gère probablement aussi la détection des commandes built-in et peut retourner prématurément si la commande est traitée en interne. Ensuite, `find_command_path(args[0], shell->env)` résout le chemin complet de l'exécutable en recherchant dans les répertoires du `PATH` ou en vérifiant les chemins absolus/relatifs.

La **gestion d'erreur de résolution** avec `if (!cmd_path)` traite le cas où la commande n'est pas trouvée dans le système. La fonction délègue cette situation à `cmd_not_found()` qui affiche probablement un message d'erreur approprié et nettoie les ressources avant de retourner. Cette approche respecte la convention Unix où les commandes inexistantes génèrent des erreurs spécifiques sans faire planter le shell.

La **préparation de l'environnement** utilise `list_to_envp(shell->env)` pour convertir la liste chaînée d'environnement du shell en tableau de chaînes au format attendu par `execve()`. Les variables temporaires `shell->exec_cmd_path_tmp` et `shell->exec_envp_tmp` stockent les pointeurs pour permettre un nettoyage ultérieur en cas de signal ou d'interruption, garantissant qu'aucune fuite mémoire ne survient même lors de terminaisons inattendues.

L'**appel d'exécution** avec `execve(cmd_path, args, envp)` remplace l'image du processus courant par le programme cible. Si `execve()` retourne, cela indique nécessairement un échec (puisqu'un `execve()` réussi ne retourne jamais). La fonction gère alors la **séquence de nettoyage d'urgence** : affichage de l'erreur avec `perror()`, libération de toutes les ressources allouées, remise à zéro des pointeurs temporaires, et terminaison du processus enfant avec le code d'erreur 127 (convention Unix pour "commande non trouvée" lors d'échecs d'exécution). Cette architecture garantit une gestion robuste des ressources même dans les scénarios d'échec, évitant les fuites mémoire dans les processus enfants du shell.

PREPARE_OR_RUN_BUILTIN
Cette fonction `prepare_or_run_builtin()` implémente un **dispatcher intelligent** qui prépare les arguments d'une commande et détermine s'il s'agit d'une commande built-in à exécuter immédiatement ou d'une commande externe nécessitant une préparation pour l'exécution ultérieure.

La fonction commence par une **validation défensive** avec `if (!cmd || !cmd->value)` qui vérifie que le token de commande est valide et contient une valeur. En cas d'échec, elle termine immédiatement le processus enfant avec `exit_child_process(shell, 1)`, évitant les segfaults lors du traitement ultérieur. Cette vérification précoce garantit que toutes les opérations suivantes travaillent avec des données cohérentes.

La **phase d'expansion** utilise `expand_cmd(cmd, shell->env)` pour traiter le token de commande et générer un tableau d'arguments complet. Cette expansion inclut probablement la substitution de variables, le traitement des guillemets, et la conversion du format token vers un format d'arguments standard. La vérification `if (!args || !args[0])` détecte les cas d'échec d'expansion ou les commandes vides, déléguant la gestion d'erreur à `cmd_not_found()` qui affiche un message approprié.

Le **mécanisme de détection de built-in** utilise `is_in_t_arr_str(shell->bcmd, args[0])` pour rechercher le nom de la commande dans la table des commandes built-in du shell. Si la fonction retourne un index valide (différent de -1), cela indique que la commande doit être traitée en interne. La fonction récupère alors le gestionnaire correspondant avec `get_builtin_handler()`, vérifie sa validité, et l'exécute directement avec `handler(shell, args)`.

La **gestion des built-ins** constitue un point de non-retour : après l'exécution d'une commande built-in, la fonction met à jour le statut de sortie du shell, libère les arguments, et termine le processus avec `exit(shell->exit_status)`. Cette approche garantit que les built-ins sont exécutés dans le contexte approprié et que leur statut de sortie est correctement propagé. Si la commande n'est pas un built-in, la fonction assigne simplement les arguments expandus à `*out_args`, permettant à la fonction appelante de procéder à l'exécution d'une commande externe avec les arguments préparés.

CMD_NOT_FOUND
Cette fonction `cmd_not_found()` implémente un **gestionnaire d'erreur spécialisé** qui traite les cas où une commande demandée n'existe pas dans le système, gérant à la fois l'affichage d'un message d'erreur informatif et la terminaison propre du processus avec le code de sortie approprié selon les conventions Unix.

La fonction commence par une **phase de nettoyage conditionnel** avec `if (args)` qui vérifie si un tableau d'arguments a été alloué avant de tenter de le libérer. Cette vérification défensive protège contre les appels où `args` pourrait être NULL (par exemple lors d'échecs d'allocation ou de parsing précoces), évitant les erreurs de segmentation. L'utilisation de `free_str_array(args)` garantit que toute la mémoire allouée pour les arguments est correctement libérée, prévenant les fuites mémoire même dans les scénarios d'erreur.

L'**affichage du message d'erreur** utilise des appels directs à `write()` sur le descripteur de fichier 2 (stderr) plutôt que `printf()` ou des fonctions de plus haut niveau. Cette approche garantit que le message d'erreur est écrit immédiatement sans mise en tampon, assurant que l'utilisateur voit l'erreur même si le processus se termine brutalement. Le message suit le format standard Unix avec le nom de la commande suivi de ": command not found\n", permettant une identification claire de la commande problématique.

La **construction du message** s'effectue en deux appels `write()` séparés : d'abord `cmd->value` avec sa longueur calculée par `ft_strlen()`, puis la chaîne littérale ": command not found\n" avec sa longueur fixe de 21 caractères. Cette approche évite la concaténation de chaînes et l'allocation mémoire supplémentaire, optimisant les performances dans un contexte d'erreur où la simplicité et la fiabilité sont prioritaires.

La **terminaison avec code d'erreur 127** via `exit_child_process(shell, 127)` respecte la convention Unix standard où le code 127 indique spécifiquement "commande non trouvée". Cette valeur de retour permet aux scripts et au shell parent de distinguer ce type d'erreur d'autres problèmes d'exécution, facilitant la gestion d'erreur dans les scripts automatisés. La fonction `exit_child_process()` gère probablement le nettoyage additionnel des ressources du shell avant la terminaison effective du processus.

RUN_BUILTIN_IF_ANY
Cette fonction `run_builtin_if_any()` implémente un **exécuteur conditionnel de commandes built-in** qui détecte si une commande correspond à une fonction intégrée au shell et l'exécute le cas échéant, servant de point de décision critique dans le système de dispatch des commandes de votre minishell.

La fonction utilise une **approche de recherche par index** en appelant `is_in_t_arr_str(shell->bcmd, args[0])` pour localiser le nom de commande dans la table des built-ins du shell. Cette fonction retourne l'index de la commande dans le tableau si elle existe, ou -1 si aucune correspondance n'est trouvée. Le test `if (idx == -1)` gère le cas où la commande n'est pas un built-in, retournant immédiatement 0 pour indiquer aux fonctions appelantes qu'elles doivent poursuivre avec l'exécution d'une commande externe.

Lorsqu'un **built-in est identifié**, la fonction récupère le gestionnaire approprié avec `get_builtin_handler(shell->bcmd, idx)`, qui retourne un pointeur vers la fonction d'implémentation correspondante. La vérification `if (!handler)` protège contre les cas d'erreur où l'index serait valide mais le gestionnaire absent (corruption de données, erreur de configuration), déclenchant un nettoyage d'urgence avec libération des arguments et terminaison du processus enfant avec un code d'erreur.

L'**exécution du built-in** s'effectue via l'appel `handler(shell, args)` qui délègue le traitement à la fonction spécialisée correspondante (comme `builtin_echo`, `builtin_cd`, etc.). Le statut de retour est stocké dans `shell->exit_status` pour maintenir la cohérence avec les conventions de codes de sortie Unix. Après l'exécution, la fonction libère les arguments avec `free_str_array(args)` et termine le processus avec `exit(shell->exit_status)`.

Cette fonction constitue un **point de non-retour** pour les commandes built-in : une fois qu'un built-in est détecté et exécuté, le processus se termine avec le code de sortie approprié, empêchant toute exécution ultérieure. Le retour de 1 à la fin n'est jamais atteint en pratique car `exit()` termine le processus, mais il documente l'intention que les built-ins sont traités de manière définitive. Cette architecture garantit que les commandes intégrées sont exécutées dans le contexte correct et que leur statut de sortie est correctement propagé au shell parent.

